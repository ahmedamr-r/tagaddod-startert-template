import { Meta, Story, Controls, Canvas, ArgTypes } from '@storybook/blocks';
import * as TableStories from './Table.stories';
import { Table } from './Table';

<Meta of={TableStories} />


REALM AGENT NAVIGATION INDEX
=============================
Quick Reference for Claude Code Agents:

üì¶ IMPORT & SETUP (Lines 28-50)
- Basic import pattern  
- Cell variants imports
- Props documentation

üéØ BASIC USAGE (Lines 51-133)
- Default implementation with columns and data
- Action buttons setup

‚ö° PERFORMANCE IMPROVEMENTS (Lines 134-278)
- Fixed Pagination Behavior (Lines 236-261): Content changes correctly when switching pages
- Optimized Filter Performance (Lines 263-271): Differentiated debounce timing for filter types
- Default Non-Striped Behavior (Lines 273-276): Modern interactive table appearance

üé® TABLE VARIANTS (Lines 279-300)
- Striped Table: Alternating row colors
- Grid Table: Cell borders
- Tabbed Table: Multiple data sets
- Static Table: Read-only display

üîÑ COLUMN MANAGEMENT (Lines 302-456)
- Column Ordering (Lines 162-209): Drag and drop reordering (disabled by default)
- Column Resizing (Lines 210-282): Interactive width adjustment (disabled by default)
- Advanced Configuration (Lines 284-312): Combining features

üîß CELL VARIANTS (Lines 320-1162)
- Quick Creation Methods (Lines 326-371): QuickColumns, createCellColumn, createCustomCellColumn
- Available Cell Types (Lines 373-392): 13 predefined variants
- Quick Usage (Lines 393-411): Helper functions
- Advanced Usage (Lines 413-460): Detailed configuration
- Data Structures (Lines 462-483): Expected data formats
- Custom Cell Creation (Lines 485-1087): Complete examples with progress bars, avatars, ratings
- Component Integration (Lines 747-885): Using other design system components
- Best Practices (Lines 915-1005): RTL, design tokens, performance
- Troubleshooting (Lines 1007-1085): Common issues and solutions

‚ö° FEATURES (Lines 1164-2212)
- Pagination (Lines 1166-1189): Page controls
- Enhanced Search/Filters (Lines 1191-2212): 
  * Complete Implementation Guide (Lines 1238-1350): Critical filtering setup
  * Data Processing (Lines 1395-1543): Filter patterns
  * Common Issues & Solutions (Lines 1853-2145): Comprehensive troubleshooting

üìä TABLE STATES (Lines 2333-2398)
- Empty State (Lines 2335-2346): No data display
- Loading State (Lines 2348-2360): Data fetching
- Error State (Lines 2362-2374): Failed requests
- Not Found State (Lines 2376-2398): Search results

üåç INTERNATIONALIZATION (Lines 2399-2413)
- RTL language support
- Arabic text handling

‚öôÔ∏è COLUMN CONFIGURATION (Lines 2415-2459)
- TanStack Table ColumnDef interface
- Custom cell rendering
- Column styling via meta

üîß ADVANCED USAGE (Lines 2461-2553)
- Controlled Table (Lines 2463-2493): Full state management
- Server-Side Data (Lines 2495-2553): Pagination, sorting, filtering

üíº COMMON USE CASES (Lines 2555-2691)
- Data Grid with Actions (Lines 2557-2599): CRUD operations
- Dashboard Analytics (Lines 2601-2641): Metrics display
- Record Selection (Lines 2643-2691): Batch operations

‚ôø ACCESSIBILITY (Lines 2693-2705)
- Semantic HTML structure
- ARIA attributes and keyboard navigation

‚öôÔ∏è TECHNICAL DETAILS (Lines 2707-2796)
- CSS Variables (Lines 2709-2732): Design tokens
- Architecture (Lines 2734-2744): TanStack foundation
- Performance (Lines 2746-2755): Large dataset optimization
- Integration (Lines 2757-2766): Other components
- Browser Support (Lines 2768-2777): Compatibility
- Dependencies (Lines 2779-2796): dnd-kit for column management

QUICK IMPLEMENTATION EXAMPLES:
- Basic table: Lines 220-229
- Fixed pagination: Lines 236-261
- Fast filters: Lines 263-271
- Non-striped default: Lines 273-276
- With pagination: Lines 1320-1332
- With filters: Lines 1340-1379
- Complete filtering: Lines 1478-1492
- Cell variants: Lines 542-554, 568-603
- Custom cells: Lines 678-801
- RTL support: Lines 2548-2556

‚ö†Ô∏è CRITICAL FILTERING NOTE:
Table component handles filter UI but NOT data filtering. You must implement filtering logic yourself and pass filtered data to the component. See Lines 1238-1350 for complete implementation guide.

‚ö†Ô∏è FALLBACK INSTRUCTION:
If you cannot find what you're looking for in the sections above, 
read the ENTIRE document from start to finish to ensure complete 
understanding of all Table component capabilities and patterns.


# Table Component

The Table component is a powerful, feature-rich data display component built on TanStack Table, offering extensive customization options including sorting, filtering, pagination, tabbed interfaces, column ordering, and column resizing.

## Overview

The Tagaddod Table component provides an intuitive way to display structured data with advanced features such as:

- Column sorting
- Text search and filtering
- Pagination
- Tabbed interfaces
- **Column ordering** with drag and drop
- **Column resizing** with interactive handles
- Customizable row styling
- Export functionality
- Error, loading, and empty states
- RTL language support

This component is ideal for data-heavy applications where users need to view, sort, search, and interact with structured information.

## Import

```jsx
// Basic table import
import { Table } from '@tagaddod/react';

// Cell variants imports
import { 
  Table, 
  QuickColumns, 
  createCellColumn, 
  createInteractiveCellColumn, 
  createActionCellColumn,
  createCustomCellColumn,
  TableCellVariants,
  CellVariantProps 
} from '@tagaddod/react';
```

## Props

<ArgTypes of={Table} />

## Basic Usage

<Canvas of={TableStories.Example} />

```jsx
import { Table } from '@tagaddod/react';
import { IconEdit, IconTrash } from '@tabler/icons-react';
import { Button } from '@tagaddod/react';

// Define column structure
const columns = [
  {
    accessorKey: 'id',
    header: 'ID',
    size: 80,
  },
  {
    accessorKey: 'name',
    header: 'Item',
    size: 250,
  },
  {
    accessorKey: 'stockCollectors',
    header: 'Dispatched to collectors',
    size: 150,
  },
  {
    accessorKey: 'stockWarehouse',
    header: 'Available at warehouse',
    size: 150,
  },
  {
    id: 'actions',
    header: '',
    cell: () => (
      <div style={{ display: 'flex', gap: '8px' }}>
        <Button
          variant="plain"
          size="micro"
          tone="neutral"
          prefixIcon={<IconEdit size={16} />}
          onClick={(e) => {
            e.stopPropagation();
            alert('Edit clicked');
          }}
        />
        <Button
          variant="plain"
          size="micro"
          tone="critical"
          prefixIcon={<IconTrash size={16} />}
          onClick={(e) => {
            e.stopPropagation();
            alert('Delete clicked');
          }}
        />
      </div>
    ),
  },
];

// Sample data
const data = [
  {
    id: 34,
    name: "ÿ≤Ÿäÿ™ ÿ≠ŸÑŸàÿ© 700 ŸÖŸÑ",
    stockCollectors: 325,
    stockWarehouse: 325,
  },
  // Additional rows...
];

// Render the table
<Table
  data={data}
  columns={columns}
  title="Inventory Stock"
  striped={false} // Default: false for interactive tables
  gridCells={false}
  showHeader={true}
  onRowClick={(row) => console.log('Row clicked:', row.original)}
/>
```

## Recent Performance Improvements ‚ö°

The Table component has been optimized with significant performance improvements and bug fixes:

### Fixed Pagination Behavior
<Canvas of={TableStories.FixedPagination} />

**Issue Fixed:** Pagination content now properly changes when switching pages. The `manualPagination` setting is correctly applied only for server-side pagination scenarios.

```jsx
// Client-side pagination (default)
const pagination = {
  pageIndex: currentPage,
  pageSize: pageSize,
  pageCount: Math.ceil(data.length / pageSize),
  onPageChange: (pageIndex) => setCurrentPage(pageIndex),
  onPageSizeChange: (pageSize) => setPageSize(pageSize),
  // isServerSide: false (default for client-side)
};

// Server-side pagination
const serverPagination = {
  pageIndex: currentPage,
  pageSize: pageSize,
  pageCount: totalPages, // From API
  onPageChange: (pageIndex) => fetchPage(pageIndex),
  onPageSizeChange: (pageSize) => fetchWithNewPageSize(pageSize),
  isServerSide: true // Enables manual pagination mode
};
```

### Optimized Filter Performance
<Canvas of={TableStories.FastFilters} />

**Performance Improvements:**
- **Dropdown filters:** Immediate response (0ms debounce)
- **Range sliders:** Fast response (100ms debounce) 
- **Text inputs:** Quick response (200ms debounce, reduced from 500ms)
- **Memory optimization:** React.memo prevents unnecessary re-renders
- **onBlur handlers:** Immediate filter application when users tab away

### Default Non-Striped Behavior
<Canvas of={TableStories.DefaultNonStriped} />

**Issue Fixed:** Table now defaults to non-striped rows (white background) for better interactivity and modern appearance. Use `striped={true}` only for static, read-only data tables.

## Error Row Highlighting Demo

Demonstration of error row highlighting with the fill-critical-secondary token:

<Canvas of={TableStories.ErrorRowHighlighting} />

## Table Variants

Explore different table configurations through these comprehensive examples:

### Striped Table
<Canvas of={TableStories.StripedTable} />

### Grid Table  
<Canvas of={TableStories.GridTable} />

### Tabbed Table
<Canvas of={TableStories.TabbedTable} />

### Static Table
<Canvas of={TableStories.StaticTable} />


## Column Management Features

The Table component includes advanced column management capabilities that allow users to customize their data view through interactive column ordering and resizing.

### Column Ordering

Column ordering allows users to reorder table columns by dragging and dropping them. This feature is **disabled by default** and must be explicitly enabled via the `enableColumnOrdering` prop. It is built using @dnd-kit for modern, accessible drag and drop interactions.

#### Basic Implementation

```jsx
import { Table } from '@tagaddod/react';

const columns = [
  {
    id: 'name',        // Important: Provide unique IDs for all columns
    accessorKey: 'name',
    header: 'Name',
    size: 200,
  },
  {
    id: 'email',
    accessorKey: 'email', 
    header: 'Email',
    size: 250,
  },
  // ... more columns
];

<Table
  data={data}
  columns={columns}
  title="Users Table"
  enableColumnOrdering={true}  // Enable column ordering
/>
```

#### Key Features

- **Default State**: Column ordering is disabled by default (`enableColumnOrdering={false}`)
- **Drag Handles**: When enabled, hover over column headers to reveal drag handles (‚ãÆ‚ãÆ‚ãÆ)
- **Visual Feedback**: Columns show visual feedback during drag operations
- **Keyboard Accessible**: Use Tab + Arrow keys + Space for reordering
- **Automatic Persistence**: Column order state is maintained during table interactions
- **RTL Support**: Proper handling for right-to-left languages

#### Best Practices

- Always provide unique `id` properties for columns
- Use descriptive column IDs that won't conflict
- Consider disabling column ordering for tables with many interactive cell variants

### Column Resizing  

Column resizing enables users to adjust column widths by dragging resize handles that appear on column borders. This feature is **disabled by default** and must be explicitly enabled via the `enableColumnResizing` prop.

#### Configuration

```jsx
import { Table } from '@tagaddod/react';

const columns = [
  {
    accessorKey: 'name',
    header: 'Name',
    size: 200,           // Initial width
    minSize: 100,        // Minimum width
    maxSize: 400,        // Maximum width
  },
  {
    accessorKey: 'email',
    header: 'Email', 
    size: 250,
    minSize: 150,
    maxSize: 500,
  },
  {
    accessorKey: 'actions',
    header: 'Actions',
    size: 100,
    enableResizing: false, // Disable resizing for this column
  },
];

<Table
  data={data}
  columns={columns}
  title="Resizable Table"
  enableColumnResizing={true}  // Enable column resizing
/>
```

#### Resize Behavior

- **Default State**: Column resizing is disabled by default (`enableColumnResizing={false}`)
- **Interactive Handles**: When enabled, resize handles appear on hover at column borders
- **Real-time Updates**: Column widths update immediately during drag
- **Constraints**: Respects `minSize` and `maxSize` boundaries
- **Visual Indicators**: Active resize handles are highlighted in blue
- **Touch Support**: Works on touch devices for mobile compatibility
- **Double-click**: Double-click resize handles to auto-fit column content

#### Column Sizing Properties

| Property | Type | Description |
|----------|------|-------------|
| `size` | `number` | Initial column width in pixels |
| `minSize` | `number` | Minimum allowed width (default: 20px) |
| `maxSize` | `number` | Maximum allowed width (default: unlimited) |
| `enableResizing` | `boolean` | Whether column can be resized (default: true) |

#### Advanced Configuration

```jsx
// Complete column management setup
<Table
  data={data}
  columns={columns}
  title="Advanced Table"
  enableColumnOrdering={true}     // Enable column ordering
  enableColumnResizing={true}     // Enable column resizing
  gridCells={true}                // Show borders for better visual feedback
  // RTL direction is automatically detected
/>
```

#### Combining Features

```jsx
// Table with both column ordering and resizing
<Table
  data={data}
  columns={columns}
  title="Full Column Management"
  enableColumnOrdering={true}   // Enable column ordering
  enableColumnResizing={true}   // Enable column resizing
  showSearch={true}
  showFilters={true}
  gridCells={true}  // Recommended for better visual feedback
/>
```

#### Column Management Summary

| Feature | Default State | How to Enable |
|---------|---------------|---------------|
| **Column Ordering** | ‚ùå Disabled | `enableColumnOrdering={true}` |
| **Column Resizing** | ‚ùå Disabled | `enableColumnResizing={true}` |

**Best Practices:**
- Use `gridCells={true}` when enabling column management features for better visual feedback
- Column ordering works best with unique column IDs
- Both features are disabled by default for better performance
- Consider performance impact with many columns (50+) when enabling both features

Use the controls panel below to:
- Toggle features on/off (search, filters, pagination, tabs, etc.)
- Switch between different table states (normal, error, empty, etc.)
- Change direction (LTR/RTL)
- Configure tab behavior
- Modify display options

## Cell Variants

The Table component includes a comprehensive cell variants system that makes it easy to create consistent, interactive table cells. This system provides predefined cell types and helper functions for common use cases.

<Canvas of={TableStories.CellVariants} />

### How to Create Table Cells

The Table component provides three main approaches for creating table cells, from simple to fully custom:

#### 1. **Quick Columns (Simplest)**
For standard cases, use the `QuickColumns` helper:
```jsx
import { QuickColumns } from '@tagaddod/react';

const columns = [
  QuickColumns.text('name', 'Name'),              // Simple text
  QuickColumns.badge('status', 'Status'),         // Status badges
  QuickColumns.number('amount', 'Amount'),        // Formatted numbers
  QuickColumns.checkbox('selected', 'Select', handleSelection),
  QuickColumns.actions('Actions', handleAction), // Action buttons
];
```

#### 2. **Pre-built Cell Variants (Flexible)**
For more control, use specific cell variant functions:
```jsx
import { createCellColumn, createInteractiveCellColumn } from '@tagaddod/react';

const columns = [
  createCellColumn('description', 'Description', 'textMultiline'),
  createCellColumn('tags', 'Tags', 'badgeMultiple'),
  createInteractiveCellColumn('priority', 'Priority', 'select', handleChange, {
    cellProps: { options: [{ label: 'High', value: 'high' }] }
  }),
];
```

#### 3. **Custom Cell Components (Full Control)**
For unique requirements, create completely custom cells:
```jsx
import { createCustomCellColumn, CellVariantProps } from '@tagaddod/react';

const CustomCell: React.FC<CellVariantProps<any>> = ({ value, row, onChange }) => {
  // Your custom cell implementation with any design system component
  return <YourCustomDesign value={value} />;
};

const columns = [
  createCustomCellColumn('custom', 'Custom', CustomCell),
];
```

### Available Cell Variants

The table supports **13 predefined cell variants** that you can use with `createCellColumn`:

| Variant Type | Cell Variant Name | Description | Data Type |
|--------------|-------------------|-------------|-----------|
| **Text** | `textSingleLine` | Basic text display with RTL support | `string` |
| **Text** | `textMultiline` | Multi-line text with proper line breaks | `string` (with `\n`) |
| **Text** | `textTruncated` | Text with ellipsis and tooltip on overflow | `string` |
| **Text** | `textSingleLineWithBadge` | Text with optional badge and prefix icon | `{text: string, badge?: string, badgeVariant?: string, prefixIcon?: ReactNode}` |
| **Badge** | `badge` | Single status badge with tone | `{text: string, tone?: 'success' \| 'warning' \| ...}` |
| **Badge** | `badgeMultiple` | Multiple badges in one cell | `Array<{text: string, tone?: string}>` |
| **Interactive** | `checkbox` | Interactive checkbox for selection | `boolean` |
| **Interactive** | `radioButton` | Radio button group for exclusive selection | `string` + options |
| **Interactive** | `select` | Dropdown selection with options | `string` + options |
| **Interactive** | `textField` | Editable text input field | `string` |
| **Data** | `updatedNumber` | Formatted numbers with locale support | `number` or `{primary: number, secondary?: number}` |
| **Actions** | `actionIcon` | Single or multiple action buttons | Any (uses onClick callback) |
| **Actions** | `actionDropdownIcon` | Action dropdown menu | `Array<{label: string, onClick: Function}>` |

### Quick Usage with Helper Functions

The easiest way to use cell variants is with the `QuickColumns` helper:

```jsx
import { Table, QuickColumns, createInteractiveCellColumn } from '@tagaddod/react';

const columns = [
  QuickColumns.text('name', 'Customer Name'),
  QuickColumns.badge('status', 'Status'),
  QuickColumns.checkbox('selected', 'Select', (checked, row) => {
    console.log(`Row ${row.id} selected: ${checked}`);
  }),
  QuickColumns.number('amount', 'Amount'),
  QuickColumns.actions('Actions', (row) => {
    console.log('Action clicked for:', row);
  }),
];
```

### Advanced Cell Variant Usage

For more control, use the detailed helper functions:

```jsx
import { 
  createCellColumn, 
  createInteractiveCellColumn, 
  createActionCellColumn 
} from '@tagaddod/react';

const columns = [
  // Text variants
  createCellColumn('customer', 'Customer', 'textSingleLine'),
  createCellColumn('description', 'Description', 'textMultiline'),
  
  // Badge variants
  createCellColumn('status', 'Status', 'badge'),
  createCellColumn('tags', 'Tags', 'badgeMultiple'),
  
  // Interactive variants
  createInteractiveCellColumn('priority', 'Priority', 'select', handlePriorityChange, {
    cellProps: { 
      options: [
        { label: 'High', value: 'high' },
        { label: 'Medium', value: 'medium' },
        { label: 'Low', value: 'low' }
      ]
    }
  }),
  
  createInteractiveCellColumn('approved', 'Approved', 'checkbox', handleApprovalChange),
  
  createInteractiveCellColumn('notes', 'Notes', 'textField', handleNotesChange, {
    cellProps: { placeholder: 'Add notes...' }
  }),
  
  // Action variants
  createActionCellColumn('Actions', 'actionIcon', handleRowAction),
  createActionCellColumn('More', 'actionDropdownIcon', () => {}, {
    actions: [
      { label: 'Edit', onClick: (row) => editRow(row) },
      { label: 'Delete', onClick: (row) => deleteRow(row) },
      { label: 'View Details', onClick: (row) => viewDetails(row) }
    ]
  })
];
```

### Data Structure for Cell Variants

Different cell variants expect specific data structures:

```jsx
const salesData = [
  {
    id: 1,
    customer: 'Olivia Rhye',                                    // textSingleLine
    description: 'Premium customer with\nmultiple orders',      // textMultiline
    status: { text: 'Active', tone: 'success' },               // badge
    tags: [                                                     // badgeMultiple
      { text: 'VIP', tone: 'success' },
      { text: 'Premium', tone: 'info' }
    ],
    selected: true,                                             // checkbox
    priority: 'high',                                           // select/radioButton
    amount: 2400.50,                                            // updatedNumber
    notes: 'Important client'                                   // textField
  }
];
```

### Creating Custom Cell Variants

You can create completely custom cell variants using the `createCustomCellColumn` helper. This gives you full control over the cell's appearance and behavior while maintaining consistency with the table system.

#### Example 1: Progress Bar Cell

```jsx
import { createCustomCellColumn, CellVariantProps } from '@tagaddod/react';

// Create custom progress bar cell
const ProgressBarCell: React.FC<CellVariantProps<number>> = ({ value }) => {
  const isRTL = document.dir === 'rtl' || document.documentElement.dir === 'rtl';
  
  return (
    <div style={{ 
      display: 'flex',
      alignItems: 'center',
      gap: 'var(--t-space-100)',
      width: '100%'
    }}>
      <div style={{ 
        flex: 1,
        height: '8px', 
        backgroundColor: 'var(--t-color-surface-tertiary)', 
        borderRadius: 'var(--t-border-radius-sm)',
        overflow: 'hidden'
      }}>
        <div 
          style={{ 
            width: `${value || 0}%`, 
            height: '100%', 
            backgroundColor: 'var(--t-color-fill-brand-primary)', 
            transition: 'width 0.3s ease'
          }} 
        />
      </div>
      <span style={{ 
        fontSize: 'var(--t-font-size-sm)',
        fontWeight: 'var(--t-font-weight-medium)',
        color: 'var(--t-color-text-secondary)',
        minWidth: '32px',
        textAlign: isRTL ? 'left' : 'right'
      }}>
        {value || 0}%
      </span>
    </div>
  );
};

// Use in column definition
const columns = [
  createCustomCellColumn('completion', 'Progress', ProgressBarCell),
];
```

#### Example 2: User Avatar Cell with Two Lines

```jsx
import { Avatar } from '@tagaddod/react';

interface UserCellData {
  name: string;
  email: string;
  avatar?: string;
}

const UserAvatarCell: React.FC<CellVariantProps<UserCellData>> = ({ value }) => {
  const isRTL = document.dir === 'rtl' || document.documentElement.dir === 'rtl';
  
  const lineHeightStyle = {
    lineHeight: isRTL ? 'var(--t-line-height-arabic, 1.2)' : 'var(--t-line-height-english, 1.5)'
  };
  
  return (
    <div style={{ 
      display: 'flex',
      alignItems: 'center',
      gap: 'var(--t-space-200)'
    }}>
      <Avatar 
        src={value?.avatar} 
        fallback={value?.name?.charAt(0) || '?'}
        size="small"
      />
      <div>
        <div style={{ 
          ...lineHeightStyle,
          font: 'var(--t-typography-body-sm-medium)',
          color: 'var(--t-color-text-primary)'
        }}>
          {value?.name || '-'}
        </div>
        <div style={{ 
          ...lineHeightStyle,
          font: 'var(--t-typography-body-sm-default)',
          color: 'var(--t-color-text-secondary)'
        }}>
          {value?.email || '-'}
        </div>
      </div>
    </div>
  );
};

// Usage with data structure
const userData = [
  {
    id: 1,
    user: {
      name: 'Ahmed Al-Rashid',
      email: 'ahmed@example.com',
      avatar: 'https://example.com/avatar1.jpg'
    },
    role: 'Admin'
  }
];

const columns = [
  createCustomCellColumn('user', 'User', UserAvatarCell),
  QuickColumns.text('role', 'Role'),
];
```

#### Example 3: Interactive Rating Cell

```jsx
import { useState } from 'react';
import { IconStar } from '@tabler/icons-react';

const RatingCell: React.FC<CellVariantProps<number>> = ({ 
  value, 
  onChange, 
  row 
}) => {
  const [hoveredStar, setHoveredStar] = useState<number | null>(null);
  
  const handleStarClick = (rating: number) => {
    onChange?.(rating, row);
  };
  
  return (
    <div style={{ 
      display: 'flex',
      gap: 'var(--t-space-050)'
    }}>
      {[1, 2, 3, 4, 5].map((star) => (
        <IconStar
          key={star}
          size={16}
          style={{
            cursor: 'pointer',
            color: (hoveredStar || value || 0) >= star 
              ? 'var(--t-color-fill-warning-primary)' 
              : 'var(--t-color-border-secondary)',
            fill: (hoveredStar || value || 0) >= star 
              ? 'var(--t-color-fill-warning-primary)' 
              : 'transparent'
          }}
          onClick={() => handleStarClick(star)}
          onMouseEnter={() => setHoveredStar(star)}
          onMouseLeave={() => setHoveredStar(null)}
        />
      ))}
    </div>
  );
};

// Use as interactive cell
const columns = [
  createInteractiveCellColumn('rating', 'Rating', 'custom', handleRatingChange, {
    cellProps: { CustomComponent: RatingCell }
  })
];
```

#### Example 4: Status Cell with Icon and Color

```jsx
import { IconCircleCheck, IconClock, IconAlertTriangle } from '@tabler/icons-react';

interface StatusCellData {
  status: 'completed' | 'pending' | 'failed';
  label: string;
}

const StatusIconCell: React.FC<CellVariantProps<StatusCellData>> = ({ value }) => {
  const isRTL = document.dir === 'rtl' || document.documentElement.dir === 'rtl';
  
  const getStatusConfig = (status: string) => {
    switch (status) {
      case 'completed':
        return {
          icon: <IconCircleCheck size={16} />,
          color: 'var(--t-color-text-success)',
          bgColor: 'var(--t-color-fill-success-secondary)'
        };
      case 'pending':
        return {
          icon: <IconClock size={16} />,
          color: 'var(--t-color-text-warning)',
          bgColor: 'var(--t-color-fill-warning-secondary)'
        };
      case 'failed':
        return {
          icon: <IconAlertTriangle size={16} />,
          color: 'var(--t-color-text-critical)',
          bgColor: 'var(--t-color-fill-critical-secondary)'
        };
      default:
        return {
          icon: <IconClock size={16} />,
          color: 'var(--t-color-text-secondary)',
          bgColor: 'var(--t-color-surface-secondary)'
        };
    }
  };
  
  const config = getStatusConfig(value?.status || '');
  
  return (
    <div style={{ 
      display: 'flex',
      alignItems: 'center',
      gap: 'var(--t-space-100)',
      padding: 'var(--t-space-100) var(--t-space-200)',
      backgroundColor: config.bgColor,
      borderRadius: 'var(--t-border-radius-sm)',
      width: 'fit-content'
    }}>
      <span style={{ color: config.color, display: 'flex' }}>
        {config.icon}
      </span>
      <span style={{ 
        font: 'var(--t-typography-body-sm-medium)',
        color: config.color,
        lineHeight: isRTL ? 'var(--t-line-height-arabic, 1.2)' : 'var(--t-line-height-english, 1.5)'
      }}>
        {value?.label || '-'}
      </span>
    </div>
  );
};

// Usage
const taskData = [
  {
    id: 1,
    task: 'Setup Database',
    status: {
      status: 'completed' as const,
      label: 'Completed'
    }
  }
];

const columns = [
  QuickColumns.text('task', 'Task'),
  createCustomCellColumn('status', 'Status', StatusIconCell),
];
```

### Custom Cells by Importing Other Components

The Table component works seamlessly with other Tagaddod Design System components. Here are examples of creating custom cells by importing and using existing components:

#### Example 5: Dropdown Actions Cell

```jsx
import { DropdownMenu, DropdownMenuTrigger, DropdownMenuContent, DropdownMenuItem } from '@tagaddod/react';
import { Button } from '@tagaddod/react';
import { IconDots, IconEdit, IconTrash, IconEye } from '@tabler/icons-react';

const DropdownActionsCell: React.FC<CellVariantProps<any>> = ({ row }) => {
  const handleEdit = () => {
    console.log('Edit:', row);
  };
  
  const handleDelete = () => {
    console.log('Delete:', row);
  };
  
  const handleView = () => {
    console.log('View:', row);
  };
  
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button
          variant="plain"
          size="micro"
          tone="neutral"
          prefixIcon={<IconDots size={16} />}
          onClick={(e) => e.stopPropagation()}
        />
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={handleView}>
          <IconEye size={16} />
          View Details
        </DropdownMenuItem>
        <DropdownMenuItem onClick={handleEdit}>
          <IconEdit size={16} />
          Edit
        </DropdownMenuItem>
        <DropdownMenuItem onClick={handleDelete} destructive>
          <IconTrash size={16} />
          Delete
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
};

const columns = [
  QuickColumns.text('name', 'Name'),
  createCustomCellColumn('actions', 'Actions', DropdownActionsCell),
];
```

#### Example 6: Toggle Switch Cell

```jsx
import { Switch } from '@tagaddod/react';

const ToggleSwitchCell: React.FC<CellVariantProps<boolean>> = ({ 
  value, 
  onChange, 
  row 
}) => {
  return (
    <Switch
      checked={value || false}
      onCheckedChange={(checked) => onChange?.(checked, row)}
      onClick={(e) => e.stopPropagation()}
    />
  );
};

const columns = [
  QuickColumns.text('feature', 'Feature'),
  createInteractiveCellColumn('enabled', 'Enabled', 'custom', handleToggleChange, {
    cellProps: { CustomComponent: ToggleSwitchCell }
  }),
];
```

#### Example 7: Tag Input Cell

```jsx
import { TagInput } from '@tagaddod/react';

const TagInputCell: React.FC<CellVariantProps<string[]>> = ({ 
  value, 
  onChange, 
  row 
}) => {
  return (
    <TagInput
      value={value || []}
      onValueChange={(tags) => onChange?.(tags, row)}
      placeholder="Add tags..."
      onClick={(e) => e.stopPropagation()}
    />
  );
};

const columns = [
  QuickColumns.text('title', 'Title'),
  createInteractiveCellColumn('tags', 'Tags', 'custom', handleTagsChange, {
    cellProps: { CustomComponent: TagInputCell }
  }),
];
```

#### Example 8: Date Picker Cell

```jsx
import { DatePicker } from '@tagaddod/react';

const DatePickerCell: React.FC<CellVariantProps<Date | null>> = ({ 
  value, 
  onChange, 
  row 
}) => {
  return (
    <DatePicker
      value={value}
      onValueChange={(date) => onChange?.(date, row)}
      onClick={(e) => e.stopPropagation()}
    />
  );
};

const columns = [
  QuickColumns.text('task', 'Task'),
  createInteractiveCellColumn('dueDate', 'Due Date', 'custom', handleDateChange, {
    cellProps: { CustomComponent: DatePickerCell }
  }),
];
```

### Extending the Cell Variants Registry

You can extend the built-in cell variants registry to add your custom variants and use them with the helper functions:

```jsx
import { TableCellVariants } from '@tagaddod/react';

// Add your custom variants to the registry
const ExtendedCellVariants = {
  ...TableCellVariants,
  progressBar: ProgressBarCell,
  userAvatar: UserAvatarCell,
  ratingStars: RatingCell,
  statusIcon: StatusIconCell,
  dropdownActions: DropdownActionsCell,
  toggleSwitch: ToggleSwitchCell,
};

// Now you can use them with helper functions
const columns = [
  createCellColumn('completion', 'Progress', 'progressBar'),
  createCellColumn('user', 'User', 'userAvatar'),
  createInteractiveCellColumn('rating', 'Rating', 'ratingStars', handleRatingChange),
  createCellColumn('status', 'Status', 'statusIcon'),
  createCustomCellColumn('actions', 'Actions', 'dropdownActions'),
];
```

### Custom Cell Best Practices

When creating custom cells, follow these best practices:

#### 1. **RTL Support**
Always include RTL detection and proper styling:
```jsx
const isRTL = document.dir === 'rtl' || document.documentElement.dir === 'rtl';
const lineHeightStyle = {
  lineHeight: isRTL ? 'var(--t-line-height-arabic, 1.2)' : 'var(--t-line-height-english, 1.5)'
};
```

#### 2. **Use Design Tokens**
Always use design system tokens for consistency:
```jsx
// ‚úÖ Good - Using design tokens
color: 'var(--t-color-text-primary)',
padding: 'var(--t-space-200)',
borderRadius: 'var(--t-border-radius-sm)',
font: 'var(--t-typography-body-sm-default)'

// ‚ùå Bad - Hard-coded values
color: '#333',
padding: '8px',
borderRadius: '4px',
font: '14px sans-serif'
```

#### 3. **Handle Click Events Properly**
Prevent event bubbling for interactive elements:
```jsx
<Button
  onClick={(e) => {
    e.stopPropagation(); // Prevent row click when button is clicked
    handleAction();
  }}
/>
```

#### 4. **Data Type Safety**
Define proper TypeScript interfaces for complex data:
```jsx
interface CustomCellData {
  primary: string;
  secondary?: string;
  metadata?: Record<string, any>;
}

const CustomCell: React.FC<CellVariantProps<CustomCellData>> = ({ value }) => {
  // Type-safe access to value properties
  return <div>{value?.primary || '-'}</div>;
};
```

#### 5. **Performance Optimization**
Use React.memo for complex cells with large datasets:
```jsx
import { memo } from 'react';

const ExpensiveCustomCell: React.FC<CellVariantProps<ComplexData>> = memo(({ value }) => {
  // Complex rendering logic
  return <div>...</div>;
});
```

### Cell Variant Props Interface

All cell variants implement the `CellVariantProps` interface:

```typescript
interface CellVariantProps<T = any> {
  value: T;                                    // The cell value
  row?: any;                                   // The entire row data
  onChange?: (value: T, row?: any) => void;    // Change handler for interactive cells
  onClick?: (row?: any) => void;               // Click handler for action cells
  options?: Array<{ label: string; value: any }>; // Options for select/radio cells
  className?: string;                          // Additional CSS classes
  [key: string]: any;                         // Additional props
}
```

### RTL Support in Cell Variants

All cell variants automatically support RTL languages with proper:
- Text alignment (right for RTL, left for LTR)
- Font family switching (Arabic fonts for RTL content)
- Line height adjustments (optimized for Arabic text)
- Layout direction (flex-direction, positioning)

The RTL detection and styling is handled automatically by each cell variant component.

### Important Notes for Cell Variants

#### Select Component Requirements
When using Select or ActionDropdown cell variants, ensure that:
- All option values are **non-empty strings**
- Empty string values are automatically filtered out
- Use meaningful values like `'high'`, `'medium'`, `'low'` instead of `''`

```jsx
// ‚úÖ Correct - Non-empty option values
const priorityOptions = [
  { label: 'High', value: 'high' },
  { label: 'Medium', value: 'medium' },
  { label: 'Low', value: 'low' }
];

// ‚ùå Incorrect - Empty string values will cause errors
const badOptions = [
  { label: 'Select...', value: '' },  // This will be filtered out
  { label: 'High', value: 'high' }
];
```

#### Badge Component Tones
Badge components use `tone` prop with these available values:
- `'default'` - Gray/neutral appearance
- `'info'` - Blue informational tone
- `'success'` - Green success tone  
- `'warning'` - Yellow/orange warning tone
- `'critical'` - Red error/critical tone
- `'magic'` - Purple/gradient special tone

#### Typography Implementation
Text cell variants use consistent typography:
- **Font**: `--t-typography-body-sm-default` for consistent styling
- **Text Single Line**: Primary text color (`--t-color-text-primary`)
- **Text Multiline**: First line uses primary color, subsequent lines use secondary color (`--t-color-text-secondary`)
- **RTL Support**: Automatic line-height adjustments for Arabic text

#### Performance Considerations
For optimal performance with cell variants:
- Use `React.memo` for custom cell components when dealing with large datasets
- Prefer static options arrays over inline object creation
- Consider virtualization for tables with 1000+ rows and complex cell variants

### Troubleshooting Cell Variants

#### Common Issues and Solutions

**"Select.Item must have a value prop that is not an empty string"**
- **Cause**: Select options contain empty string values
- **Solution**: Ensure all option values are non-empty strings or they will be filtered out automatically

**Cell variant not rendering correctly**
- **Cause**: Incorrect data structure passed to cell variant
- **Solution**: Check the expected data structure for each variant in the documentation above

**TypeScript errors with custom cell variants**
- **Cause**: Custom component doesn't implement `CellVariantProps` interface
- **Solution**: Ensure your custom component extends `React.FC<CellVariantProps<YourDataType>>`

**Interactive cells not updating**
- **Cause**: Missing or incorrect `onChange` callback
- **Solution**: Use `createInteractiveCellColumn` and provide proper onChange handler

```jsx
// ‚úÖ Correct interactive cell setup
createInteractiveCellColumn('status', 'Status', 'select', (value, row) => {
  console.log('Status changed:', value, 'for row:', row);
  // Update your data state here
}, {
  cellProps: { 
    options: [
      { label: 'Active', value: 'active' },
      { label: 'Inactive', value: 'inactive' }
    ]
  }
})
```

## Custom Cell Development Summary

The Table component's cell variant system provides multiple levels of customization:

### Choose Your Approach

| Approach | Best For | Complexity | Flexibility |
|----------|----------|------------|-------------|
| **QuickColumns** | Standard data types (text, numbers, badges) | Low | Low |
| **Cell Variants** | Common interactive patterns | Medium | Medium |
| **Custom Cells** | Unique designs, complex interactions | High | High |
| **Component Import** | Using existing design system components | Medium | High |

### Quick Reference Guide

```jsx
// 1. Simple text and numbers
QuickColumns.text('name', 'Name')
QuickColumns.number('amount', 'Amount')

// 2. Interactive elements
QuickColumns.checkbox('selected', 'Select', handleChange)
QuickColumns.actions('Actions', handleClick)

// 3. Custom styling with variants
createCellColumn('status', 'Status', 'badge')
createCellColumn('description', 'Description', 'textMultiline')

// 4. Interactive variants with options
createInteractiveCellColumn('priority', 'Priority', 'select', handleChange, {
  cellProps: { options: [...] }
})

// 5. Fully custom cells
const CustomCell = ({ value, row, onChange }) => (
  <YourCustomComponent value={value} onChange={onChange} />
);
createCustomCellColumn('custom', 'Custom', CustomCell)

// 6. Using other design system components
const ComponentCell = ({ value, onChange, row }) => (
  <Switch checked={value} onCheckedChange={(v) => onChange(v, row)} />
);
createCustomCellColumn('toggle', 'Toggle', ComponentCell)
```

### Data Structure Patterns

```jsx
// Text variants
name: "Ahmed Al-Rashid"                    // textSingleLine
description: "Line 1\nLine 2\nLine 3"     // textMultiline

// Badge variants  
status: { text: "Active", tone: "success" }              // badge
tags: [{ text: "VIP", tone: "success" }, {...}]         // badgeMultiple

// Complex text with badge
user: { 
  text: "Ahmed", 
  badge: "VIP", 
  badgeVariant: "success",
  prefixIcon: <IconUser />
}                                          // textSingleLineWithBadge

// Numbers
amount: 1250.50                            // updatedNumber (simple)
counts: { primary: 100, secondary: 50 }   // updatedNumber (complex)

// Interactive
selected: true                             // checkbox
priority: "high"                          // select, radioButton
notes: "Custom text"                      // textField
```

The Table component's cell system is designed to be both powerful and approachable, allowing you to start simple and add complexity only when needed. Whether you're displaying basic data or creating complex interactive experiences, the cell variant system provides the tools and patterns to build consistent, accessible, and performant table interfaces.

## Features

### Pagination

Add pagination to control the number of records displayed per page.

```jsx
import { useState } from 'react';

const [pageIndex, setPageIndex] = useState(0);
const [pageSize, setPageSize] = useState(5);

<Table
  data={data}
  columns={columns}
  title="Inventory Stock"
  pagination={{
    pageIndex,
    pageSize,
    pageCount: Math.ceil(data.length / pageSize),
    onPageChange: setPageIndex,
    onPageSizeChange: setPageSize,
    pageSizeOptions: [5, 10, 20, 50],
  }}
/>
```

### Enhanced Search and Filters

Enable search functionality and filters for more targeted data exploration.

```jsx
const [searchQuery, setSearchQuery] = useState('');
const [filters, setFilters] = useState({
  status: 'active',
});
const [isFilterBarVisible, setIsFilterBarVisible] = useState(true);

<Table
  data={data}
  columns={columns}
  title="Inventory Stock"
  showSearch={true}
  showFilters={true}
  showFilterBar={isFilterBarVisible}
  showExport={true}
  searchQuery={searchQuery}
  onSearchChange={setSearchQuery}
  activeFilters={filters}
  onFilterChange={setFilters}
  onFilterClick={() => setIsFilterBarVisible(!isFilterBarVisible)}
  onExport={() => alert('Export clicked')}
  filterOptions={{
    status: {
      label: 'Status',
      options: [
        { label: 'All', value: 'all' },
        { label: 'Active', value: 'active' },
        { label: 'Inactive', value: 'inactive' },
      ],
    },
    category: {
      label: 'Category',
      options: [
        { label: 'All', value: 'all' },
        { label: 'Food', value: 'food' },
        { label: 'Cleaning', value: 'cleaning' },
        { label: 'Drinks', value: 'drinks' },
      ],
    },
  }}
/>
```

## Complete Filtering Implementation Guide

### Important: Data Filtering Logic Required

**‚ö†Ô∏è Critical Understanding**: The Table component handles the filter UI (dropdowns, search bar, filter chips) but **does not automatically filter your data**. You must implement the data filtering logic yourself and pass the filtered data to the Table component.

### Step-by-Step Filtering Implementation

Here's a complete example showing how to implement filtering correctly:

```jsx
import { useState, useMemo } from 'react';
import { Table, QuickColumns } from '@tagaddod/react';

function ProductTable() {
  // 1. Raw data (unfiltered)
  const rawData = [
    { id: 1, name: 'Coffee Beans', status: { text: 'Active', value: 'active' }, category: 'food', price: 25.99 },
    { id: 2, name: 'Dish Soap', status: { text: 'Inactive', value: 'inactive' }, category: 'cleaning', price: 3.99 },
    { id: 3, name: 'Orange Juice', status: { text: 'Active', value: 'active' }, category: 'drinks', price: 4.50 },
  ];

  // 2. Filter state
  const [searchQuery, setSearchQuery] = useState('');
  const [filters, setFilters] = useState({});

  // 3. Data filtering function
  const filterData = (data, searchQuery, filters) => {
    let filtered = [...data];

    // Apply search filter
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(item => 
        item.name.toLowerCase().includes(query) ||
        item.id.toString().includes(query)
      );
    }

    // Apply status filter
    if (filters.status && filters.status !== 'all') {
      filtered = filtered.filter(item => item.status.value === filters.status);
    }

    // Apply category filter
    if (filters.category && filters.category !== 'all') {
      filtered = filtered.filter(item => item.category === filters.category);
    }

    return filtered;
  };

  // 4. Get filtered data using useMemo for performance
  const filteredData = useMemo(() => 
    filterData(rawData, searchQuery, filters), 
    [rawData, searchQuery, filters]
  );

  // 5. Filter options configuration
  const filterOptions = {
    status: {
      label: 'Status',
      options: [
        { label: 'All', value: 'all' },
        { label: 'Active', value: 'active' },
        { label: 'Inactive', value: 'inactive' },
      ],
    },
    category: {
      label: 'Category',
      options: [
        { label: 'All', value: 'all' },
        { label: 'Food', value: 'food' },
        { label: 'Cleaning', value: 'cleaning' },
        { label: 'Drinks', value: 'drinks' },
      ],
    },
  };

  const columns = [
    QuickColumns.text('id', 'ID'),
    QuickColumns.text('name', 'Product Name'),
    { 
      accessorKey: 'status',
      header: 'Status',
      cell: ({ getValue }) => getValue().text 
    },
    QuickColumns.text('category', 'Category'),
    { 
      accessorKey: 'price',
      header: 'Price',
      cell: ({ getValue }) => `$${getValue()}` 
    },
  ];

  // 6. Pass filtered data to Table component
  return (
    <Table
      data={filteredData}  // ‚Üê Important: Use filtered data, not raw data
      columns={columns}
      title="Product Inventory"
      showSearch={true}
      searchQuery={searchQuery}
      onSearchChange={setSearchQuery}
      showFilters={true}
      showFilterBar={true}
      activeFilters={filters}
      onFilterChange={setFilters}
      filterOptions={filterOptions}
    />
  );
}
```

### Key Implementation Points

#### 1. **Separate Data from UI**
```jsx
// ‚úÖ Correct: Filter data before passing to Table
const filteredData = filterData(rawData, searchQuery, filters);
<Table data={filteredData} ... />

// ‚ùå Incorrect: Passing raw data without filtering
<Table data={rawData} ... />
```

#### 2. **Use useMemo for Performance**
```jsx
// ‚úÖ Correct: Memoize filtered data to prevent unnecessary recalculations
const filteredData = useMemo(() => 
  filterData(rawData, searchQuery, filters), 
  [rawData, searchQuery, filters]
);
```

#### 3. **Handle All Filter Types**
Your filter function must handle both search queries and active filters:
```jsx
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  // Search filtering
  if (searchQuery.trim()) {
    // Apply search logic
  }

  // Individual filter processing
  Object.keys(filters).forEach(filterKey => {
    if (filters[filterKey] && filters[filterKey] !== 'all') {
      // Apply specific filter logic
    }
  });

  return filtered;
};
```

## Data Processing for Filters

### Understanding Filter Data Flow

```
Raw Data ‚Üí Search Filter ‚Üí Category Filters ‚Üí Filtered Data ‚Üí Table Component
```

The Table component receives the final filtered data and handles:
- ‚úÖ Displaying filtered results
- ‚úÖ Pagination of filtered data
- ‚úÖ Filter UI (dropdowns, search bar)
- ‚úÖ Filter state management

You handle:
- ‚úÖ Data filtering logic
- ‚úÖ Search implementation
- ‚úÖ Filter value mapping
- ‚úÖ Performance optimization

### Common Data Structures and Filtering Patterns

#### Pattern 1: Simple String/Number Filtering
```jsx
// Data structure
const data = [
  { id: 1, name: 'Product A', category: 'electronics', active: true },
  { id: 2, name: 'Product B', category: 'books', active: false },
];

// Filter function
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase();
    filtered = filtered.filter(item => 
      item.name.toLowerCase().includes(query) ||
      item.id.toString().includes(query)
    );
  }

  if (filters.category && filters.category !== 'all') {
    filtered = filtered.filter(item => item.category === filters.category);
  }

  if (filters.status && filters.status !== 'all') {
    const isActive = filters.status === 'active';
    filtered = filtered.filter(item => item.active === isActive);
  }

  return filtered;
};
```

#### Pattern 2: Object-Based Data Filtering
```jsx
// Data structure with object properties
const data = [
  { 
    id: 1, 
    name: 'User A', 
    status: { text: 'Active', value: 'active' },
    role: { text: 'Admin', value: 'admin' }
  }
];

// Filter function with object property access
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase();
    filtered = filtered.filter(item => 
      item.name.toLowerCase().includes(query)
    );
  }

  if (filters.status && filters.status !== 'all') {
    filtered = filtered.filter(item => item.status.value === filters.status);
  }

  if (filters.role && filters.role !== 'all') {
    filtered = filtered.filter(item => item.role.value === filters.role);
  }

  return filtered;
};
```

#### Pattern 3: Date Range Filtering
```jsx
// Data with dates
const data = [
  { id: 1, name: 'Order A', createdDate: '2024-01-15', amount: 100 },
  { id: 2, name: 'Order B', createdDate: '2024-01-20', amount: 250 },
];

// Filter function with date handling
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase();
    filtered = filtered.filter(item => 
      item.name.toLowerCase().includes(query)
    );
  }

  // Date range filtering
  if (filters.dateRange && filters.dateRange !== 'all') {
    const now = new Date();
    let startDate;

    switch (filters.dateRange) {
      case 'last7days':
        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case 'last30days':
        startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        break;
      default:
        startDate = null;
    }

    if (startDate) {
      filtered = filtered.filter(item => 
        new Date(item.createdDate) >= startDate
      );
    }
  }

  // Amount range filtering
  if (filters.amountRange && filters.amountRange !== 'all') {
    switch (filters.amountRange) {
      case 'under100':
        filtered = filtered.filter(item => item.amount < 100);
        break;
      case '100to500':
        filtered = filtered.filter(item => item.amount >= 100 && item.amount <= 500);
        break;
      case 'over500':
        filtered = filtered.filter(item => item.amount > 500);
        break;
    }
  }

  return filtered;
};
```

## Filter Value Mapping

### The Most Common Filtering Issue

**Problem**: Filter option values don't match data structure values.

#### Example Issue
```jsx
// Filter options use lowercase values
const filterOptions = {
  status: {
    options: [
      { label: 'Active', value: 'active' },    // ‚Üê lowercase
      { label: 'Inactive', value: 'inactive' } // ‚Üê lowercase
    ]
  }
};

// But data uses object with text property
const data = [
  { status: { text: 'Active', tone: 'success' } },  // ‚Üê 'Active' not 'active'
  { status: { text: 'Inactive', tone: 'warning' } } // ‚Üê 'Inactive' not 'inactive'
];

// ‚ùå This won't work:
filtered = filtered.filter(item => item.status.value === filters.status);
// item.status.value is undefined!

// ‚ùå This won't work either:
filtered = filtered.filter(item => item.status.text === filters.status);
// 'Active' !== 'active'
```

#### Solution: Value Mapping
```jsx
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  if (filters.status && filters.status !== 'all') {
    // Create mapping from filter values to data values
    const statusMap = {
      'active': 'Active',     // filter value ‚Üí data value
      'inactive': 'Inactive'  // filter value ‚Üí data value
    };
    
    const expectedStatusText = statusMap[filters.status];
    filtered = filtered.filter(item => item.status.text === expectedStatusText);
  }

  return filtered;
};
```

#### Advanced Value Mapping with Locale Support
```jsx
const filterData = (data, searchQuery, filters, locale = 'en') => {
  let filtered = [...data];

  if (filters.status && filters.status !== 'all') {
    // Locale-aware mapping
    const statusMap = {
      'active': locale === 'ar' ? 'ŸÜÿ¥ÿ∑' : 'Active',
      'inactive': locale === 'ar' ? 'ÿ∫Ÿäÿ± ŸÜÿ¥ÿ∑' : 'Inactive'
    };
    
    const expectedStatusText = statusMap[filters.status];
    filtered = filtered.filter(item => item.status.text === expectedStatusText);
  }

  return filtered;
};
```

### Multiple Data Structure Patterns

#### Pattern A: Direct String Comparison
```jsx
// Data: { category: 'electronics' }
// Filter: { category: 'electronics' }
// Solution: Direct comparison
filtered = filtered.filter(item => item.category === filters.category);
```

#### Pattern B: Object with Value Property
```jsx
// Data: { status: { text: 'Active', value: 'active' } }
// Filter: { status: 'active' }
// Solution: Compare with value property
filtered = filtered.filter(item => item.status.value === filters.status);
```

#### Pattern C: Object with Text Property (Mapping Required)
```jsx
// Data: { status: { text: 'Active', tone: 'success' } }
// Filter: { status: 'active' }
// Solution: Map filter value to text value
const statusMap = { 'active': 'Active', 'inactive': 'Inactive' };
const expectedText = statusMap[filters.status];
filtered = filtered.filter(item => item.status.text === expectedText);
```

#### Pattern D: Array Contains Filtering
```jsx
// Data: { tags: ['urgent', 'customer', 'priority'] }
// Filter: { tag: 'urgent' }
// Solution: Array includes check
filtered = filtered.filter(item => item.tags.includes(filters.tag));
```

## Common Filtering Patterns

### 1. Search + Multiple Filters
```jsx
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  // Step 1: Apply search filter first
  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase();
    filtered = filtered.filter(item => 
      // Search across multiple fields
      item.name.toLowerCase().includes(query) ||
      item.description.toLowerCase().includes(query) ||
      item.id.toString().includes(query) ||
      item.email.toLowerCase().includes(query)
    );
  }

  // Step 2: Apply each filter
  Object.keys(filters).forEach(filterKey => {
    const filterValue = filters[filterKey];
    
    if (filterValue && filterValue !== 'all') {
      switch (filterKey) {
        case 'status':
          filtered = filtered.filter(item => item.status.value === filterValue);
          break;
        case 'department':
          filtered = filtered.filter(item => item.department === filterValue);
          break;
        case 'role':
          filtered = filtered.filter(item => item.role.value === filterValue);
          break;
        // Add more filter cases as needed
      }
    }
  });

  return filtered;
};
```

### 2. Hierarchical/Nested Filtering
```jsx
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  // Search in nested properties
  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase();
    filtered = filtered.filter(item => 
      item.user.name.toLowerCase().includes(query) ||
      item.user.email.toLowerCase().includes(query) ||
      item.company.name.toLowerCase().includes(query) ||
      item.project.title.toLowerCase().includes(query)
    );
  }

  // Filter nested object properties
  if (filters.userStatus && filters.userStatus !== 'all') {
    filtered = filtered.filter(item => item.user.status === filters.userStatus);
  }

  if (filters.companyType && filters.companyType !== 'all') {
    filtered = filtered.filter(item => item.company.type === filters.companyType);
  }

  return filtered;
};
```

### 3. Numeric Range Filtering
```jsx
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  if (searchQuery.trim()) {
    // ... search logic
  }

  // Price range filtering
  if (filters.priceRange && filters.priceRange !== 'all') {
    switch (filters.priceRange) {
      case 'under50':
        filtered = filtered.filter(item => item.price < 50);
        break;
      case '50to100':
        filtered = filtered.filter(item => item.price >= 50 && item.price <= 100);
        break;
      case 'over100':
        filtered = filtered.filter(item => item.price > 100);
        break;
    }
  }

  // Quantity filtering
  if (filters.quantity && filters.quantity !== 'all') {
    const [min, max] = filters.quantity.split('-').map(Number);
    filtered = filtered.filter(item => 
      item.quantity >= min && (max ? item.quantity <= max : true)
    );
  }

  return filtered;
};
```

### 4. Date-Based Filtering
```jsx
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  if (searchQuery.trim()) {
    // ... search logic
  }

  // Date range filtering
  if (filters.dateRange && filters.dateRange !== 'all') {
    const now = new Date();
    let filterDate;

    switch (filters.dateRange) {
      case 'today':
        filterDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        filtered = filtered.filter(item => 
          new Date(item.createdAt) >= filterDate
        );
        break;
      case 'thisWeek':
        filterDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        filtered = filtered.filter(item => 
          new Date(item.createdAt) >= filterDate
        );
        break;
      case 'thisMonth':
        filterDate = new Date(now.getFullYear(), now.getMonth(), 1);
        filtered = filtered.filter(item => 
          new Date(item.createdAt) >= filterDate
        );
        break;
    }
  }

  // Status with overdue logic
  if (filters.status && filters.status !== 'all') {
    filtered = filtered.filter(item => {
      if (filters.status === 'overdue') {
        return new Date(item.dueDate) < now && item.status !== 'completed';
      }
      return item.status === filters.status;
    });
  }

  return filtered;
};
```

### 5. Performance-Optimized Filtering for Large Datasets
```jsx
import { useMemo, useCallback } from 'react';

const filterData = useCallback((data, searchQuery, filters) => {
  // Early return for no filters
  if (!searchQuery.trim() && Object.keys(filters).length === 0) {
    return data;
  }

  let filtered = data; // Don't spread large arrays unnecessarily

  // Apply most selective filters first
  if (filters.status && filters.status !== 'all') {
    filtered = filtered.filter(item => item.status.value === filters.status);
  }

  if (filters.category && filters.category !== 'all') {
    filtered = filtered.filter(item => item.category === filters.category);
  }

  // Apply search last (usually least selective)
  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase();
    filtered = filtered.filter(item => 
      item.name.toLowerCase().includes(query) ||
      item.id.toString().includes(query)
    );
  }

  return filtered;
}, []);

// In component
const filteredData = useMemo(() => 
  filterData(rawData, searchQuery, filters), 
  [rawData, searchQuery, filters, filterData]
);
```

## Filtering Troubleshooting

### Common Issues and Solutions

#### 1. "Filters are not working / no effect when I change filters"

**Symptoms**: Filter dropdowns appear and can be changed, but table data doesn't update.

**Most Likely Cause**: Missing data filtering implementation.

**Solution**: Implement data filtering logic and pass filtered data to Table:
```jsx
// ‚ùå Problem: Passing raw data without filtering
<Table data={rawData} activeFilters={filters} onFilterChange={setFilters} />

// ‚úÖ Solution: Filter data before passing to Table
const filteredData = useMemo(() => 
  filterData(rawData, searchQuery, filters), 
  [rawData, searchQuery, filters]
);
<Table data={filteredData} activeFilters={filters} onFilterChange={setFilters} />
```

#### 2. "Filter shows 'No results' but data should match"

**Symptoms**: Filter is applied but returns no results when data should match.

**Most Likely Cause**: Filter value doesn't match data structure.

**Diagnosis**: Check filter values vs. actual data values:
```jsx
// Debug by logging filter values and data structure
console.log('Filter value:', filters.status); // e.g., 'active'
console.log('Data structure:', data[0].status); // e.g., { text: 'Active', tone: 'success' }
```

**Solution**: Implement value mapping:
```jsx
const filterData = (data, searchQuery, filters) => {
  if (filters.status && filters.status !== 'all') {
    // Map filter values to data values
    const statusMap = {
      'active': 'Active',    // filter value ‚Üí data text value
      'inactive': 'Inactive'
    };
    const expectedText = statusMap[filters.status];
    filtered = filtered.filter(item => item.status.text === expectedText);
  }
};
```

#### 3. "Search works but filters don't" or "Filters work but search doesn't"

**Symptoms**: One filtering mechanism works but the other doesn't.

**Most Likely Cause**: Incomplete filtering logic or state management issues.

**Solution**: Ensure both search and filters are handled in the same function:
```jsx
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  // Both search and filters must be implemented
  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase();
    filtered = filtered.filter(item => 
      item.name.toLowerCase().includes(query)
    );
  }

  // AND apply filters
  if (filters.status && filters.status !== 'all') {
    filtered = filtered.filter(item => item.status.value === filters.status);
  }

  return filtered;
};
```

#### 4. "Filters reset when I search" or "Search clears when I filter"

**Symptoms**: Using one filter type clears the other.

**Most Likely Cause**: State management conflict or missing dependencies in useMemo.

**Solution**: Ensure both states are preserved and dependencies are correct:
```jsx
// ‚úÖ Correct: Both states maintained separately
const [searchQuery, setSearchQuery] = useState('');
const [filters, setFilters] = useState({});

// ‚úÖ Correct: Both dependencies in useMemo
const filteredData = useMemo(() => 
  filterData(rawData, searchQuery, filters), 
  [rawData, searchQuery, filters] // Both dependencies included
);
```

#### 5. "Performance issues with filtering"

**Symptoms**: Slow response when typing in search or changing filters.

**Solutions**:

**A. Debounce search input:**
```jsx
import { useMemo, useState, useEffect } from 'react';
import { debounce } from 'lodash'; // or implement your own

const [searchQuery, setSearchQuery] = useState('');
const [debouncedSearchQuery, setDebouncedSearchQuery] = useState('');

const debouncedSearch = useMemo(
  () => debounce((query) => setDebouncedSearchQuery(query), 300),
  []
);

useEffect(() => {
  debouncedSearch(searchQuery);
}, [searchQuery, debouncedSearch]);

// Use debouncedSearchQuery in filtering
const filteredData = useMemo(() => 
  filterData(rawData, debouncedSearchQuery, filters), 
  [rawData, debouncedSearchQuery, filters]
);
```

**B. Optimize filter function for large datasets:**
```jsx
const filterData = useCallback((data, searchQuery, filters) => {
  // Early return if no filters
  if (!searchQuery.trim() && Object.keys(filters).length === 0) {
    return data;
  }

  // Apply most selective filters first
  let filtered = data;
  
  // Apply exact match filters first (more selective)
  if (filters.status && filters.status !== 'all') {
    filtered = filtered.filter(item => item.status.value === filters.status);
  }
  
  // Apply search last (usually least selective)
  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase();
    filtered = filtered.filter(item => 
      item.name.toLowerCase().includes(query)
    );
  }

  return filtered;
}, []);
```

#### 6. "Filter dropdown options not showing"

**Symptoms**: Filter button appears but clicking doesn't show filter options.

**Possible Causes & Solutions**:

**A. Missing `showFilterBar` prop:**
```jsx
<Table
  showFilters={true}
  showFilterBar={true}  // ‚Üê Add this
  filterOptions={filterOptions}
/>
```

**B. Invalid filter options structure:**
```jsx
// ‚ùå Incorrect structure
const filterOptions = {
  status: ['Active', 'Inactive'] // Wrong format
};

// ‚úÖ Correct structure
const filterOptions = {
  status: {
    label: 'Status',
    options: [
      { label: 'All', value: 'all' },
      { label: 'Active', value: 'active' },
      { label: 'Inactive', value: 'inactive' }
    ]
  }
};
```

#### 7. "TypeScript errors with filter functions"

**Symptoms**: TypeScript compilation errors related to filter implementation.

**Solution**: Proper typing for filter functions:
```tsx
interface FilterState {
  [key: string]: string | undefined;
}

interface DataItem {
  id: number;
  name: string;
  status: { text: string; value: string };
  // ... other properties
}

const filterData = (
  data: DataItem[], 
  searchQuery: string, 
  filters: FilterState
): DataItem[] => {
  let filtered = [...data];
  
  // Implementation with proper typing
  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase();
    filtered = filtered.filter(item => 
      item.name.toLowerCase().includes(query)
    );
  }

  return filtered;
};
```

#### 8. "Pagination not updating with filtered data"

**Symptoms**: Page count or pagination doesn't reflect filtered results.

**Most Likely Cause**: Pagination using raw data length instead of filtered data length.

**Solution**: Use filtered data for pagination calculations:
```jsx
// ‚ùå Wrong: Using raw data length
pageCount: Math.ceil(rawData.length / pageSize)

// ‚úÖ Correct: Using filtered data length
pageCount: Math.ceil(filteredData.length / pageSize)
```

### Debugging Filtering Issues

#### Step-by-Step Debugging Process

1. **Log filter state changes:**
```jsx
useEffect(() => {
  console.log('Filters changed:', filters);
}, [filters]);

useEffect(() => {
  console.log('Search query changed:', searchQuery);
}, [searchQuery]);
```

2. **Log filtered data:**
```jsx
const filteredData = useMemo(() => {
  const result = filterData(rawData, searchQuery, filters);
  console.log('Filtered data:', result.length, 'items out of', rawData.length);
  return result;
}, [rawData, searchQuery, filters]);
```

3. **Test filter function in isolation:**
```jsx
// Test your filter function directly
const testFilters = { status: 'active' };
const testResult = filterData(rawData, '', testFilters);
console.log('Test filter result:', testResult);
```

4. **Verify data structure:**
```jsx
// Log first item to verify structure
console.log('Data structure sample:', rawData[0]);
console.log('Expected filter value:', filters.status);
```

#### Quick Checklist for Filter Implementation

- [ ] ‚úÖ Filter function implemented and handles both search and filters
- [ ] ‚úÖ Filtered data passed to Table component (not raw data)
- [ ] ‚úÖ useMemo used with correct dependencies
- [ ] ‚úÖ Filter options structure is correct (label + options array)
- [ ] ‚úÖ `showFilterBar={true}` prop added to Table
- [ ] ‚úÖ Value mapping implemented if data structure doesn't match filter values
- [ ] ‚úÖ Pagination uses filtered data length
- [ ] ‚úÖ State management preserves both search and filter states
- [ ] ‚úÖ Performance optimizations applied for large datasets

### Best Practices for Filtering

#### 1. **Consistent Filter Function Pattern**
```jsx
const filterData = (data, searchQuery, filters) => {
  let filtered = [...data];

  // 1. Apply search first
  if (searchQuery.trim()) {
    // search logic
  }

  // 2. Apply filters in logical order
  Object.keys(filters).forEach(key => {
    if (filters[key] && filters[key] !== 'all') {
      // filter logic
    }
  });

  return filtered;
};
```

#### 2. **Reusable Filter Utilities**
```jsx
// Create reusable filter utilities
const createTextFilter = (searchFields) => (data, query) => {
  if (!query.trim()) return data;
  
  const lowerQuery = query.toLowerCase();
  return data.filter(item => 
    searchFields.some(field => 
      String(item[field]).toLowerCase().includes(lowerQuery)
    )
  );
};

const createSelectFilter = (field, valueMapping = {}) => (data, value) => {
  if (!value || value === 'all') return data;
  
  const expectedValue = valueMapping[value] || value;
  return data.filter(item => {
    const itemValue = typeof item[field] === 'object' ? item[field].text : item[field];
    return itemValue === expectedValue;
  });
};

// Usage
const nameFilter = createTextFilter(['name', 'email']);
const statusFilter = createSelectFilter('status', { 'active': 'Active' });
```

#### 3. **Comprehensive Filter Options**
```jsx
const filterOptions = {
  status: {
    label: 'Status',
    type: 'select', // explicit type
    options: [
      { label: 'All Statuses', value: 'all' },
      { label: 'Active', value: 'active' },
      { label: 'Inactive', value: 'inactive' }
    ]
  },
  // More filter configurations...
};
```

### Table with Tabs

Create tabbed interfaces to organize different data sets.

```jsx
const [activeTab, setActiveTab] = useState('inventory');

<Table
  data={data}
  columns={columns}
  title="Inventory Management"
  showTabs={true}
  tabItems={[
    { id: 'inventory', label: 'Inventory Stock', active: activeTab === 'inventory', badge: productData.length },
    { id: 'orders', label: 'Orders', active: activeTab === 'orders', badge: orderData.length },
  ]}
  onTabChange={(tabId) => {
    setActiveTab(tabId);
    console.log('Tab changed to:', tabId);
  }}
/>
```

### Enhanced Tabs with Automatic Data Switching

For more complex tabbed interfaces, use `tableTabs` to define complete configurations for each tab.

```jsx
<Table
  data={[]} // Default data (not used with tableTabs)
  columns={[]} // Default columns (not used with tableTabs)
  title="Inventory Management"
  showTabs={true}
  tableTabs={[
    {
      id: 'inventory',
      label: 'Inventory Stock',
      active: true, // This tab will be active by default
      badge: productData.length,
      data: productData,
      columns: productColumns,
      title: 'Inventory Stock',
    },
    {
      id: 'orders',
      label: 'Orders',
      badge: orderData.length,
      data: orderData,
      columns: orderColumns,
      title: 'Order History',
    },
  ]}
  onRowClick={(row) => console.log('Row clicked:', row.original)}
/>
```

### Grid Cells

Enable grid cells to show borders between cells for better data visualization.

```jsx
<Table
  data={data}
  columns={columns}
  title="Inventory Stock"
  striped={false}
  gridCells={true}
/>
```

### Striped Rows

Use striped rows **only for read-only data** without interactive elements. Striped rows should be avoided when the table contains interactive components like buttons, checkboxes, or form inputs as they can interfere with hover states and user interactions.

```jsx
// ‚úÖ Good - Read-only data display
<Table
  data={readOnlyData}
  columns={displayColumns}
  title="Report Data"
  striped={true}
  onRowClick={undefined} // No row interactions
/>

// ‚ùå Avoid - Interactive data with form elements
<Table
  data={interactiveData}
  columns={cellVariantColumns}
  title="Editable Data"
  striped={false} // Keep false for better UX
  onRowClick={handleRowClick}
/>
```

### Static Tables (No Hover Effects)

For purely static data displays like reports or dashboards where user interaction is not needed, you can disable row hover effects using the `disableRowHover` prop.

```jsx
// ‚úÖ Static table - perfect for reports and read-only displays
<Table
  data={reportData}
  columns={reportColumns}
  title="Monthly Report"
  striped={true}
  disableRowHover={true}
  showSearch={false}
  showFilters={false}
  showPagination={false}
/>
```

**When to use `disableRowHover`:**
- Static data reports that won't be modified
- Dashboard summary tables
- Print-friendly table layouts
- Performance-critical displays with many rows
- Tables embedded in cards or confined spaces

## Table States

### Empty State

Show a message when there's no data to display.

```jsx
<Table
  data={[]}
  columns={columns}
  title="Inventory Stock"
  state="empty"
  emptyMessage="There are no records to display."
/>
```

### Loading State

Display a loading indicator while data is being fetched.

```jsx
<Table
  data={[]}
  columns={columns}
  title="Inventory Stock"
  state="loading"
/>
```

### Error State

Show an error message when data retrieval fails.

```jsx
<Table
  data={[]}
  columns={columns}
  title="Inventory Stock"
  state="error"
  errorMessage="Error in data retrieving. Don't worry, it's our fault. Please try again later."
/>
```

### Not Found State

Indicate when a search yields no results. The not found state features a title/subtitle structure with customizable messages.

```jsx
<Table
  data={[]}
  columns={columns}
  title="Inventory Stock"
  state="notFound"
  notFoundMessage="No available results for 'searched item'"
  notFoundSubtitle="Try using different search terms or check your spelling"
  searchQuery="searched item"
/>
```

**Not Found State Features:**
- **Icon**: Uses `IconSearchOff` with 32px size in a 72px circular background
- **Title**: Uses `body-lg-semibold` typography with primary text color
- **Subtitle**: Uses `body-md-default` typography with secondary text color
- **Customizable**: Both title and subtitle messages can be customized
- **Defaults**: Provides sensible default messages if not specified

## Internationalization and RTL Support

The Table component provides comprehensive Right-to-Left (RTL) language support when used with the `ThemeProvider`. This includes automatic font switching, proper text alignment, table layout mirroring, and Arabic text rendering throughout all table elements including headers, cells, filters, pagination, and states.

### Using with ThemeProvider

For full RTL support, wrap your application with `ThemeProvider`:

```jsx
import { ThemeProvider, Table, QuickColumns } from '@tagaddod-design/react';

function App() {
  return (
    <ThemeProvider defaultDirection="rtl" defaultLocale="ar">
      <Table
        data={arabicData}
        columns={arabicColumns}
        title="ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖÿÆÿ≤ŸàŸÜ"
        showSearch={true}
        showFilters={true}
        pagination={{
          pageIndex: 0,
          pageSize: 10,
          pageCount: Math.ceil(arabicData.length / 10),
        }}
      />
    </ThemeProvider>
  );
}
```

### Automatic RTL Adjustments

When RTL is enabled via ThemeProvider, the Table component automatically:

1. **Font Switching**: Changes from Outfit (English) to Tajawal (Arabic) font
2. **Layout Mirroring**: Mirrors table layout, column alignment, and interactive elements
3. **Text Alignment**: Changes text alignment to right-aligned for Arabic content
4. **Icon Positioning**: Adjusts sort icons, filter icons, and action buttons for RTL flow
5. **Pagination Controls**: Mirrors pagination layout and navigation flow

### Basic Table in RTL

```jsx
import { useTheme } from '@tagaddod-design/react';

function RTLInventoryTable() {
  const { isRTL } = useTheme();
  
  const inventoryData = isRTL ? [
    { id: 1, name: 'ÿ≤Ÿäÿ™ ÿßŸÑÿ≤Ÿäÿ™ŸàŸÜ 500 ŸÖŸÑ', category: 'ÿ∑ÿπÿßŸÖ', stock: 150, price: 25.50 },
    { id: 2, name: 'ÿµÿßÿ®ŸàŸÜ ÿ∫ÿ≥ŸäŸÑ ÿßŸÑÿ£ÿ∑ÿ®ÿßŸÇ', category: 'ÿ™ŸÜÿ∏ŸäŸÅ', stock: 85, price: 12.00 },
    { id: 3, name: 'ÿπÿµŸäÿ± ÿ®ÿ±ÿ™ŸÇÿßŸÑ ÿ∑ÿ®ŸäÿπŸä', category: 'ŸÖÿ¥ÿ±Ÿàÿ®ÿßÿ™', stock: 200, price: 8.75 }
  ] : [
    { id: 1, name: 'Olive Oil 500ml', category: 'Food', stock: 150, price: 25.50 },
    { id: 2, name: 'Dish Soap', category: 'Cleaning', stock: 85, price: 12.00 },
    { id: 3, name: 'Orange Juice Natural', category: 'Drinks', stock: 200, price: 8.75 }
  ];

  const columns = [
    QuickColumns.text('id', isRTL ? 'ÿßŸÑŸÖÿπÿ±ŸÅ' : 'ID'),
    QuickColumns.text('name', isRTL ? 'ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÜÿ™ÿ¨' : 'Product Name'),
    QuickColumns.text('category', isRTL ? 'ÿßŸÑŸÅÿ¶ÿ©' : 'Category'),
    QuickColumns.number('stock', isRTL ? 'ÿßŸÑŸÖÿÆÿ≤ŸàŸÜ' : 'Stock'),
    {
      accessorKey: 'price',
      header: isRTL ? 'ÿßŸÑÿ≥ÿπÿ±' : 'Price',
      cell: ({ getValue }) => `${getValue()} ${isRTL ? 'ÿ±.ÿ≥' : 'SAR'}`
    }
  ];

  return (
    <div style={{ direction: isRTL ? 'rtl' : 'ltr' }}>
      <Table
        data={inventoryData}
        columns={columns}
        title={isRTL ? 'ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖÿÆÿ≤ŸàŸÜ' : 'Inventory Management'}
        showSearch={true}
        searchPlaceholder={isRTL ? 'ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™...' : 'Search products...'}
      />
    </div>
  );
}
```

### Advanced Table with Filters in RTL

```jsx
function RTLAdvancedTable() {
  const { isRTL } = useTheme();
  const [searchQuery, setSearchQuery] = useState('');
  const [filters, setFilters] = useState({});
  
  const productData = isRTL ? [
    { 
      id: 1, 
      name: 'ÿ≠ŸÑŸäÿ® ŸÉÿßŸÖŸÑ ÿßŸÑÿØÿ≥ŸÖ', 
      status: { text: 'ŸÖÿ™ŸàŸÅÿ±', value: 'available', tone: 'success' },
      category: 'ŸÖŸÜÿ™ÿ¨ÿßÿ™ ÿßŸÑÿ£ŸÑÿ®ÿßŸÜ',
      supplier: { name: 'ŸÖÿ≤ÿßÿ±ÿπ ÿßŸÑÿÆŸäÿ±', city: 'ÿßŸÑÿ±Ÿäÿßÿ∂' },
      price: 15.50,
      lastUpdated: '2024-01-15'
    },
    { 
      id: 2, 
      name: 'ÿÆÿ®ÿ≤ ÿ£ÿ≥ŸÖÿ± ÿ∑ÿßÿ≤ÿ¨', 
      status: { text: 'ŸÖŸÜÿÆŸÅÿ∂', value: 'low', tone: 'warning' },
      category: 'ÿßŸÑŸÖÿÆÿ®Ÿàÿ≤ÿßÿ™',
      supplier: { name: 'ŸÖÿÆÿ®ÿ≤ ÿßŸÑŸÅÿ¨ÿ±', city: 'ÿ¨ÿØÿ©' },
      price: 3.25,
      lastUpdated: '2024-01-14'
    }
  ] : [
    {
      id: 1,
      name: 'Whole Milk',
      status: { text: 'Available', value: 'available', tone: 'success' },
      category: 'Dairy',
      supplier: { name: 'Fresh Farms', city: 'Riyadh' },
      price: 15.50,
      lastUpdated: '2024-01-15'
    },
    {
      id: 2,
      name: 'Brown Bread Fresh',
      status: { text: 'Low Stock', value: 'low', tone: 'warning' },
      category: 'Bakery',
      supplier: { name: 'Dawn Bakery', city: 'Jeddah' },
      price: 3.25,
      lastUpdated: '2024-01-14'
    }
  ];

  const columns = [
    QuickColumns.text('id', isRTL ? 'ÿßŸÑŸÖÿπÿ±ŸÅ' : 'ID'),
    QuickColumns.text('name', isRTL ? 'ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÜÿ™ÿ¨' : 'Product Name'),
    {
      accessorKey: 'status',
      header: isRTL ? 'ÿßŸÑÿ≠ÿßŸÑÿ©' : 'Status',
      cell: ({ getValue }) => {
        const status = getValue();
        return (
          <Badge variant={status.tone}>
            {status.text}
          </Badge>
        );
      }
    },
    QuickColumns.text('category', isRTL ? 'ÿßŸÑŸÅÿ¶ÿ©' : 'Category'),
    {
      accessorKey: 'supplier',
      header: isRTL ? 'ÿßŸÑŸÖŸàÿ±ÿØ' : 'Supplier',
      cell: ({ getValue }) => {
        const supplier = getValue();
        return (
          <div style={{
            fontFamily: isRTL ? 'var(--t-font-family-arabic)' : 'var(--t-font-family-primary)',
            lineHeight: isRTL ? 'var(--t-line-height-arabic, 1.2)' : 'var(--t-line-height-english, 1.5)'
          }}>
            <div style={{ fontWeight: 600 }}>{supplier.name}</div>
            <div style={{ fontSize: '12px', color: 'var(--t-color-text-subtle)' }}>
              {supplier.city}
            </div>
          </div>
        );
      }
    },
    {
      accessorKey: 'price',
      header: isRTL ? 'ÿßŸÑÿ≥ÿπÿ±' : 'Price',
      cell: ({ getValue }) => `${getValue()} ${isRTL ? 'ÿ±.ÿ≥' : 'SAR'}`
    }
  ];

  const filterOptions = {
    status: {
      label: isRTL ? 'ÿßŸÑÿ≠ÿßŸÑÿ©' : 'Status',
      options: isRTL ? [
        { label: 'ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ÿßŸÑÿßÿ™', value: 'all' },
        { label: 'ŸÖÿ™ŸàŸÅÿ±', value: 'available' },
        { label: 'ŸÖŸÜÿÆŸÅÿ∂', value: 'low' },
        { label: 'ŸÜŸÅÿ∞', value: 'out' }
      ] : [
        { label: 'All Statuses', value: 'all' },
        { label: 'Available', value: 'available' },
        { label: 'Low Stock', value: 'low' },
        { label: 'Out of Stock', value: 'out' }
      ]
    },
    category: {
      label: isRTL ? 'ÿßŸÑŸÅÿ¶ÿ©' : 'Category',
      options: isRTL ? [
        { label: 'ÿ¨ŸÖŸäÿπ ÿßŸÑŸÅÿ¶ÿßÿ™', value: 'all' },
        { label: 'ŸÖŸÜÿ™ÿ¨ÿßÿ™ ÿßŸÑÿ£ŸÑÿ®ÿßŸÜ', value: 'dairy' },
        { label: 'ÿßŸÑŸÖÿÆÿ®Ÿàÿ≤ÿßÿ™', value: 'bakery' },
        { label: 'ÿßŸÑŸÑÿ≠ŸàŸÖ', value: 'meat' }
      ] : [
        { label: 'All Categories', value: 'all' },
        { label: 'Dairy', value: 'dairy' },
        { label: 'Bakery', value: 'bakery' },
        { label: 'Meat', value: 'meat' }
      ]
    }
  };

  return (
    <div style={{ direction: isRTL ? 'rtl' : 'ltr' }}>
      <Table
        data={productData}
        columns={columns}
        title={isRTL ? 'ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™ ÿßŸÑŸÖÿ™ŸÇÿØŸÖÿ©' : 'Advanced Product Management'}
        showSearch={true}
        showFilters={true}
        showFilterBar={true}
        searchQuery={searchQuery}
        onSearchChange={setSearchQuery}
        activeFilters={filters}
        onFilterChange={setFilters}
        filterOptions={filterOptions}
        searchPlaceholder={isRTL ? 'ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä ÿßŸÑŸÖŸÜÿ™ÿ¨ÿßÿ™ ŸàÿßŸÑŸÖŸàÿ±ÿØŸäŸÜ...' : 'Search products and suppliers...'}
        pagination={{
          pageIndex: 0,
          pageSize: 10,
          pageCount: Math.ceil(productData.length / 10),
        }}
      />
    </div>
  );
}
```

### Tabbed Table in RTL

```jsx
function RTLTabbedTable() {
  const { isRTL } = useTheme();
  const [activeTab, setActiveTab] = useState('inventory');

  const inventoryData = isRTL ? [
    { id: 1, name: 'ÿ£ÿ±ÿ≤ ÿ®ÿ≥ŸÖÿ™Ÿä 5 ŸÉŸäŸÑŸà', stock: 45, price: 28.50 },
    { id: 2, name: 'ÿ≤Ÿäÿ™ ÿØŸàÿßÿ± ÿßŸÑÿ¥ŸÖÿ≥ 1 ŸÑÿ™ÿ±', stock: 30, price: 18.00 }
  ] : [
    { id: 1, name: 'Basmati Rice 5kg', stock: 45, price: 28.50 },
    { id: 2, name: 'Sunflower Oil 1L', stock: 30, price: 18.00 }
  ];

  const ordersData = isRTL ? [
    { id: 101, customer: 'ÿ£ÿ≠ŸÖÿØ ÿßŸÑÿ¥ŸÖÿ±Ÿä', total: 245.50, status: 'ŸÖŸÉÿ™ŸÖŸÑ' },
    { id: 102, customer: 'ŸÅÿßÿ∑ŸÖÿ© ÿßŸÑÿπÿ™Ÿäÿ®Ÿä', total: 189.25, status: 'ŸÇŸäÿØ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©' }
  ] : [
    { id: 101, customer: 'Ahmed Al-Shammari', total: 245.50, status: 'Completed' },
    { id: 102, customer: 'Fatima Al-Otaibi', total: 189.25, status: 'Processing' }
  ];

  const tabItems = isRTL ? [
    { id: 'inventory', label: 'ÿßŸÑŸÖÿÆÿ≤ŸàŸÜ', active: activeTab === 'inventory', badge: inventoryData.length },
    { id: 'orders', label: 'ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™', active: activeTab === 'orders', badge: ordersData.length },
    { id: 'reports', label: 'ÿßŸÑÿ™ŸÇÿßÿ±Ÿäÿ±', active: activeTab === 'reports', badge: 0 }
  ] : [
    { id: 'inventory', label: 'Inventory', active: activeTab === 'inventory', badge: inventoryData.length },
    { id: 'orders', label: 'Orders', active: activeTab === 'orders', badge: ordersData.length },
    { id: 'reports', label: 'Reports', active: activeTab === 'reports', badge: 0 }
  ];

  const getCurrentData = () => {
    switch (activeTab) {
      case 'inventory': return inventoryData;
      case 'orders': return ordersData;
      default: return [];
    }
  };

  const getCurrentColumns = () => {
    const baseColumns = activeTab === 'inventory' 
      ? [
          QuickColumns.text('id', isRTL ? 'ÿßŸÑŸÖÿπÿ±ŸÅ' : 'ID'),
          QuickColumns.text('name', isRTL ? 'ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÜÿ™ÿ¨' : 'Product Name'),
          QuickColumns.number('stock', isRTL ? 'ÿßŸÑŸÉŸÖŸäÿ©' : 'Stock'),
          {
            accessorKey: 'price',
            header: isRTL ? 'ÿßŸÑÿ≥ÿπÿ±' : 'Price',
            cell: ({ getValue }) => `${getValue()} ${isRTL ? 'ÿ±.ÿ≥' : 'SAR'}`
          }
        ]
      : [
          QuickColumns.text('id', isRTL ? 'ÿ±ŸÇŸÖ ÿßŸÑÿ∑ŸÑÿ®' : 'Order ID'),
          QuickColumns.text('customer', isRTL ? 'ÿßŸÑÿπŸÖŸäŸÑ' : 'Customer'),
          {
            accessorKey: 'total',
            header: isRTL ? 'ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä' : 'Total',
            cell: ({ getValue }) => `${getValue()} ${isRTL ? 'ÿ±.ÿ≥' : 'SAR'}`
          },
          QuickColumns.text('status', isRTL ? 'ÿßŸÑÿ≠ÿßŸÑÿ©' : 'Status')
        ];
    
    return baseColumns;
  };

  return (
    <div style={{ direction: isRTL ? 'rtl' : 'ltr' }}>
      <Table
        data={getCurrentData()}
        columns={getCurrentColumns()}
        title={isRTL ? 'ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÜÿ∏ÿßŸÖ ÿßŸÑŸÖÿ™ŸÉÿßŸÖŸÑÿ©' : 'Integrated System Management'}
        showTabs={true}
        tabItems={tabItems}
        onTabChange={setActiveTab}
        showSearch={true}
        searchPlaceholder={isRTL ? 'ÿßŸÑÿ®ÿ≠ÿ´...' : 'Search...'}
      />
    </div>
  );
}
```

### Cell Variants in RTL

```jsx
function RTLCellVariantsTable() {
  const { isRTL } = useTheme();

  const employeeData = isRTL ? [
    {
      id: 1,
      employee: {
        name: 'ÿ≥ÿßÿ±ÿ© ÿ£ÿ≠ŸÖÿØ',
        email: 'sara.ahmed@company.com',
        avatar: '/avatars/sara.jpg'
      },
      department: 'ÿßŸÑÿ™ÿ∑ŸàŸäÿ±',
      status: { text: 'ŸÜÿ¥ÿ∑', tone: 'success' },
      skills: [
        { text: 'React', tone: 'info' },
        { text: 'TypeScript', tone: 'default' }
      ],
      rating: 4,
      notes: 'ŸÖŸàÿ∏ŸÅÿ© ŸÖÿ™ŸÖŸäÿ≤ÿ© ŸÅŸä ÿßŸÑŸÅÿ±ŸäŸÇ',
      active: true,
      completion: 85
    }
  ] : [
    {
      id: 1,
      employee: {
        name: 'Sarah Ahmed',
        email: 'sara.ahmed@company.com',
        avatar: '/avatars/sara.jpg'
      },
      department: 'Development',
      status: { text: 'Active', tone: 'success' },
      skills: [
        { text: 'React', tone: 'info' },
        { text: 'TypeScript', tone: 'default' }
      ],
      rating: 4,
      notes: 'Outstanding team member',
      active: true,
      completion: 85
    }
  ];

  const columns = [
    QuickColumns.text('id', isRTL ? 'ÿßŸÑŸÖÿπÿ±ŸÅ' : 'ID'),
    createCustomCellColumn('employee', isRTL ? 'ÿßŸÑŸÖŸàÿ∏ŸÅ' : 'Employee', ({ value }) => {
      return (
        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
          <Avatar 
            src={value.avatar} 
            fallback={value.name.charAt(0)}
            size="small"
          />
          <div>
            <div style={{
              fontWeight: 600,
              fontFamily: isRTL ? 'var(--t-font-family-arabic)' : 'var(--t-font-family-primary)',
              lineHeight: isRTL ? 'var(--t-line-height-arabic, 1.2)' : 'var(--t-line-height-english, 1.5)'
            }}>
              {value.name}
            </div>
            <div style={{
              fontSize: '12px',
              color: 'var(--t-color-text-subtle)',
              fontFamily: isRTL ? 'var(--t-font-family-arabic)' : 'var(--t-font-family-primary)',
              lineHeight: isRTL ? 'var(--t-line-height-arabic, 1.2)' : 'var(--t-line-height-english, 1.5)'
            }}>
              {value.email}
            </div>
          </div>
        </div>
      );
    }),
    QuickColumns.text('department', isRTL ? 'ÿßŸÑŸÇÿ≥ŸÖ' : 'Department'),
    createCellColumn('status', isRTL ? 'ÿßŸÑÿ≠ÿßŸÑÿ©' : 'Status', 'badge'),
    createCellColumn('skills', isRTL ? 'ÿßŸÑŸÖŸáÿßÿ±ÿßÿ™' : 'Skills', 'badgeMultiple'),
    createInteractiveCellColumn('rating', isRTL ? 'ÿßŸÑÿ™ŸÇŸäŸäŸÖ' : 'Rating', 'custom', (rating, row) => {
      console.log('Rating changed for', row.employee.name, ':', rating);
    }, {
      cellProps: {
        CustomComponent: ({ value, onChange, row }) => (
          <div style={{ display: 'flex', gap: '2px' }}>
            {[1, 2, 3, 4, 5].map(star => (
              <IconStar
                key={star}
                size={16}
                style={{
                  cursor: 'pointer',
                  color: star <= (value || 0) ? 'var(--t-color-fill-warning-primary)' : 'var(--t-color-border-secondary)',
                  fill: star <= (value || 0) ? 'var(--t-color-fill-warning-primary)' : 'transparent'
                }}
                onClick={() => onChange?.(star, row)}
              />
            ))}
          </div>
        )
      }
    }),
    createInteractiveCellColumn('notes', isRTL ? 'ÿßŸÑŸÖŸÑÿßÿ≠ÿ∏ÿßÿ™' : 'Notes', 'textField', (notes, row) => {
      console.log('Notes updated for', row.employee.name, ':', notes);
    }),
    createInteractiveCellColumn('active', isRTL ? 'ŸÖŸÅÿπŸÑ' : 'Active', 'custom', (active, row) => {
      console.log('Status toggled for', row.employee.name, ':', active);
    }, {
      cellProps: {
        CustomComponent: ({ value, onChange, row }) => (
          <Switch
            checked={value || false}
            onCheckedChange={(checked) => onChange?.(checked, row)}
            onClick={(e) => e.stopPropagation()}
          />
        )
      }
    })
  ];

  return (
    <div style={{ direction: isRTL ? 'rtl' : 'ltr' }}>
      <Table
        data={employeeData}
        columns={columns}
        title={isRTL ? 'ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖŸàÿ∏ŸÅŸäŸÜ' : 'Employee Management'}
        showSearch={true}
        searchPlaceholder={isRTL ? 'ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä ÿßŸÑŸÖŸàÿ∏ŸÅŸäŸÜ...' : 'Search employees...'}
      />
    </div>
  );
}
```

### Empty and Error States in RTL

```jsx
function RTLTableStates() {
  const { isRTL } = useTheme();
  const [currentState, setCurrentState] = useState('normal');

  const columns = [
    QuickColumns.text('id', isRTL ? 'ÿßŸÑŸÖÿπÿ±ŸÅ' : 'ID'),
    QuickColumns.text('name', isRTL ? 'ÿßŸÑÿßÿ≥ŸÖ' : 'Name'),
    QuickColumns.text('status', isRTL ? 'ÿßŸÑÿ≠ÿßŸÑÿ©' : 'Status')
  ];

  const getStateConfig = () => {
    switch (currentState) {
      case 'empty':
        return {
          state: 'empty',
          emptyMessage: isRTL ? 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ≥ÿ¨ŸÑÿßÿ™ ŸÑŸÑÿπÿ±ÿ∂.' : 'There are no records to display.',
          data: []
        };
      case 'loading':
        return {
          state: 'loading',
          data: []
        };
      case 'error':
        return {
          state: 'error',
          errorMessage: isRTL 
            ? 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßÿ≥ÿ™ÿ±ÿ¨ÿßÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™. ŸÑÿß ÿ™ŸÇŸÑŸÇÿå ÿ•ŸÜŸáÿß ŸÖÿ¥ŸÉŸÑÿ© ŸÖŸÜ ÿ¨ÿßŸÜÿ®ŸÜÿß. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇÿßŸã.' 
            : 'Error in data retrieving. Don\'t worry, it\'s our fault. Please try again later.',
          data: []
        };
      case 'notFound':
        return {
          state: 'notFound',
          notFoundMessage: isRTL ? 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÜÿ™ÿßÿ¶ÿ¨ ŸÖÿ™ÿßÿ≠ÿ© ŸÑŸÄ "ÿßŸÑÿ®ÿ≠ÿ´ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®"' : 'No available results for "search term"',
          notFoundSubtitle: isRTL 
            ? 'ÿ¨ÿ±ÿ® ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÉŸÑŸÖÿßÿ™ ÿ®ÿ≠ÿ´ ŸÖÿÆÿ™ŸÑŸÅÿ© ÿ£Ÿà ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ•ŸÖŸÑÿßÿ°' 
            : 'Try using different search terms or check your spelling',
          searchQuery: isRTL ? 'ÿßŸÑÿ®ÿ≠ÿ´ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®' : 'search term',
          data: []
        };
      default:
        return {
          state: 'normal',
          data: [
            { id: 1, name: isRTL ? 'ÿ£ÿ≠ŸÖÿØ ŸÖÿ≠ŸÖÿØ' : 'Ahmed Mohamed', status: isRTL ? 'ŸÜÿ¥ÿ∑' : 'Active' },
            { id: 2, name: isRTL ? 'ŸÅÿßÿ∑ŸÖÿ© ÿ£ÿ≠ŸÖÿØ' : 'Fatima Ahmed', status: isRTL ? 'ÿ∫Ÿäÿ± ŸÜÿ¥ÿ∑' : 'Inactive' }
          ]
        };
    }
  };

  const stateConfig = getStateConfig();

  return (
    <div style={{ direction: isRTL ? 'rtl' : 'ltr' }}>
      <div style={{ marginBottom: '16px', display: 'flex', gap: '8px' }}>
        {['normal', 'empty', 'loading', 'error', 'notFound'].map(state => (
          <Button
            key={state}
            variant={currentState === state ? 'primary' : 'outlined'}
            size="sm"
            onClick={() => setCurrentState(state)}
          >
            {isRTL ? {
              normal: 'ÿπÿßÿØŸä',
              empty: 'ŸÅÿßÿ±ÿ∫',
              loading: 'ÿ™ÿ≠ŸÖŸäŸÑ',
              error: 'ÿÆÿ∑ÿ£',
              notFound: 'ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ'
            }[state] : {
              normal: 'Normal',
              empty: 'Empty',
              loading: 'Loading',
              error: 'Error',
              notFound: 'Not Found'
            }[state]}
          </Button>
        ))}
      </div>
      
      <Table
        data={stateConfig.data}
        columns={columns}
        title={isRTL ? 'ÿ≠ÿßŸÑÿßÿ™ ÿßŸÑÿ¨ÿØŸàŸÑ ÿßŸÑŸÖÿÆÿ™ŸÑŸÅÿ©' : 'Different Table States'}
        state={stateConfig.state}
        emptyMessage={stateConfig.emptyMessage}
        errorMessage={stateConfig.errorMessage}
        notFoundMessage={stateConfig.notFoundMessage}
        notFoundSubtitle={stateConfig.notFoundSubtitle}
        searchQuery={stateConfig.searchQuery}
        showSearch={true}
      />
    </div>
  );
}
```

### Column Management in RTL

```jsx
function RTLColumnManagement() {
  const { isRTL } = useTheme();

  const projectData = isRTL ? [
    {
      id: 'PRJ001',
      name: 'ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ™ÿ¨ÿßÿ±ÿ© ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸäÿ©',
      manager: 'ÿ£ÿ≠ŸÖÿØ ÿßŸÑÿ≤Ÿáÿ±ÿßŸÜŸä',
      status: 'ŸÇŸäÿØ ÿßŸÑÿ™ÿ∑ŸàŸäÿ±',
      priority: 'ÿπÿßŸÑŸäÿ©',
      deadline: '2024-03-15',
      budget: 150000
    },
    {
      id: 'PRJ002', 
      name: 'ŸÜÿ∏ÿßŸÖ ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ',
      manager: 'ÿ≥ÿßÿ±ÿ© ÿßŸÑŸÖÿßŸÑŸÉŸä',
      status: 'ŸÖŸÉÿ™ŸÖŸÑ',
      priority: 'ŸÖÿ™Ÿàÿ≥ÿ∑ÿ©',
      deadline: '2024-02-28',
      budget: 95000
    }
  ] : [
    {
      id: 'PRJ001',
      name: 'E-commerce Application',
      manager: 'Ahmed Al-Zahrani',
      status: 'In Development',
      priority: 'High',
      deadline: '2024-03-15',
      budget: 150000
    },
    {
      id: 'PRJ002',
      name: 'Content Management System',
      manager: 'Sarah Al-Malki', 
      status: 'Completed',
      priority: 'Medium',
      deadline: '2024-02-28',
      budget: 95000
    }
  ];

  const columns = [
    {
      id: 'projectId',
      accessorKey: 'id',
      header: isRTL ? 'ŸÖÿπÿ±ŸÅ ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ' : 'Project ID',
      size: 120
    },
    {
      id: 'projectName',
      accessorKey: 'name',
      header: isRTL ? 'ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ' : 'Project Name',
      size: 250,
      minSize: 150,
      maxSize: 400
    },
    {
      id: 'projectManager',
      accessorKey: 'manager',
      header: isRTL ? 'ŸÖÿØŸäÿ± ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ' : 'Project Manager',
      size: 180,
      cell: ({ getValue }) => (
        <div style={{
          fontFamily: isRTL ? 'var(--t-font-family-arabic)' : 'var(--t-font-family-primary)',
          lineHeight: isRTL ? 'var(--t-line-height-arabic, 1.2)' : 'var(--t-line-height-english, 1.5)'
        }}>
          {getValue()}
        </div>
      )
    },
    {
      id: 'projectStatus',
      accessorKey: 'status',
      header: isRTL ? 'ÿ≠ÿßŸÑÿ© ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ' : 'Status',
      size: 150,
      cell: ({ getValue }) => {
        const status = getValue();
        const getStatusTone = (status) => {
          if (isRTL) {
            return status === 'ŸÖŸÉÿ™ŸÖŸÑ' ? 'success' : status === 'ŸÇŸäÿØ ÿßŸÑÿ™ÿ∑ŸàŸäÿ±' ? 'info' : 'default';
          }
          return status === 'Completed' ? 'success' : status === 'In Development' ? 'info' : 'default';
        };
        
        return (
          <Badge variant={getStatusTone(status)}>
            {status}
          </Badge>
        );
      }
    },
    {
      id: 'projectPriority',
      accessorKey: 'priority',
      header: isRTL ? 'ÿßŸÑÿ£ŸàŸÑŸàŸäÿ©' : 'Priority',
      size: 120
    },
    {
      id: 'projectDeadline',
      accessorKey: 'deadline',
      header: isRTL ? 'ÿßŸÑŸÖŸàÿπÿØ ÿßŸÑŸÜŸáÿßÿ¶Ÿä' : 'Deadline',
      size: 130
    },
    {
      id: 'projectBudget',
      accessorKey: 'budget',
      header: isRTL ? 'ÿßŸÑŸÖŸäÿ≤ÿßŸÜŸäÿ©' : 'Budget',
      size: 130,
      cell: ({ getValue }) => `${getValue().toLocaleString()} ${isRTL ? 'ÿ±.ÿ≥' : 'SAR'}`
    }
  ];

  return (
    <div style={{ direction: isRTL ? 'rtl' : 'ltr' }}>
      <Table
        data={projectData}
        columns={columns}
        title={isRTL ? 'ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖÿ¥ÿßÿ±Ÿäÿπ ŸÖÿπ ÿ™ÿÆÿµŸäÿµ ÿßŸÑÿ£ÿπŸÖÿØÿ©' : 'Project Management with Column Customization'}
        enableColumnOrdering={true}
        enableColumnResizing={true}
        gridCells={true}
        showSearch={true}
        searchPlaceholder={isRTL ? 'ÿßŸÑÿ®ÿ≠ÿ´ ŸÅŸä ÿßŸÑŸÖÿ¥ÿßÿ±Ÿäÿπ...' : 'Search projects...'}
        pagination={{
          pageIndex: 0,
          pageSize: 10,
          pageCount: Math.ceil(projectData.length / 10),
        }}
      />
    </div>
  );
}
```

### RTL Best Practices

1. **Always use ThemeProvider** for proper RTL support and font switching
2. **Test with actual Arabic content** to ensure proper text rendering and alignment
3. **Use `useTheme` hook** to access RTL state and theme information
4. **Consider column widths** - Arabic text may require different spacing than English
5. **Test interactive elements** like filters, pagination, and cell variants in RTL
6. **Validate search functionality** with Arabic search terms and proper text matching
7. **Ensure proper data structures** for bilingual content in tables
8. **Test complex layouts** like tabbed tables and column management in RTL contexts

## Column Configuration

The Table component accepts columns defined according to TanStack Table's `ColumnDef` interface, with additional Tagaddod-specific properties for styling.

```jsx
const columns = [
  // Standard column with accessor and header
  {
    accessorKey: 'id',
    header: 'ID',
    size: 80,
  },
  
  // Column with custom cell rendering
  {
    accessorKey: 'status',
    header: 'Status',
    size: 150,
    cell: info => (
      <span 
        style={{ 
          color: 
            info.getValue() === 'Completed' ? 'var(--t-color-text-success)' :
            info.getValue() === 'Pending' ? 'var(--t-color-text-warning)' :
            'var(--t-color-text-info)'
        }}
      >
        {info.getValue()}
      </span>
    ),
  },
  
  // Column with custom styling via meta
  {
    id: 'actions',
    header: '',
    cell: () => (/* Action buttons */),
    meta: {
      headerClassName: 'custom-header',
      cellClassName: 'custom-cell',
      width: '100px',
    },
  },
];
```

## Advanced Usage

### Controlled Table

Full control of table state for advanced integration needs.

```jsx
const [sorting, setSorting] = useState([]);
const [globalFilter, setGlobalFilter] = useState('');
const [pagination, setPagination] = useState({
  pageIndex: 0,
  pageSize: 10,
});
const [filters, setFilters] = useState({});

<Table
  data={data}
  columns={columns}
  title="Advanced Table"
  searchQuery={globalFilter}
  onSearchChange={setGlobalFilter}
  pagination={{
    pageIndex: pagination.pageIndex,
    pageSize: pagination.pageSize,
    pageCount: Math.ceil(data.length / pagination.pageSize),
    onPageChange: (pageIndex) => setPagination(prev => ({ ...prev, pageIndex })),
    onPageSizeChange: (pageSize) => setPagination(prev => ({ ...prev, pageSize })),
  }}
  defaultSorting={sorting}
  activeFilters={filters}
  onFilterChange={setFilters}
/>
```

### Server-Side Data

For tables with server-side pagination, sorting, and filtering.

```jsx
const [data, setData] = useState([]);
const [totalItems, setTotalItems] = useState(0);
const [loading, setLoading] = useState(false);
const [pagination, setPagination] = useState({
  pageIndex: 0,
  pageSize: 10,
});
const [sorting, setSorting] = useState([]);
const [filters, setFilters] = useState({});

// Fetch data on state changes
useEffect(() => {
  const fetchData = async () => {
    setLoading(true);
    try {
      const response = await api.fetchData({
        page: pagination.pageIndex,
        limit: pagination.pageSize,
        sort: sorting.length > 0 ? { 
          field: sorting[0].id, 
          direction: sorting[0].desc ? 'desc' : 'asc' 
        } : undefined,
        filters,
      });
      
      setData(response.data);
      setTotalItems(response.total);
    } catch (error) {
      console.error('Error fetching data:', error);
    } finally {
      setLoading(false);
    }
  };
  
  fetchData();
}, [pagination, sorting, filters]);

<Table
  data={data}
  columns={columns}
  title="Server-Side Table"
  state={loading ? 'loading' : 'normal'}
  pagination={{
    pageIndex: pagination.pageIndex,
    pageSize: pagination.pageSize,
    pageCount: Math.ceil(totalItems / pagination.pageSize),
    onPageChange: (pageIndex) => setPagination(prev => ({ ...prev, pageIndex })),
    onPageSizeChange: (pageSize) => setPagination(prev => ({ ...prev, pageSize })),
  }}
  defaultSorting={sorting}
  activeFilters={filters}
  onFilterChange={setFilters}
/>
```

## Common Use Cases

### Data Grid with Row Actions

Table with row actions for data management operations.

```jsx
<Table
  data={users}
  columns={[
    { accessorKey: 'name', header: 'Name' },
    { accessorKey: 'email', header: 'Email' },
    { accessorKey: 'role', header: 'Role' },
    {
      id: 'actions',
      header: 'Actions',
      cell: ({ row }) => (
        <div style={{ display: 'flex', gap: '8px' }}>
          <Button
            variant="plain"
            size="micro"
            tone="neutral"
            prefixIcon={<IconEdit size={16} />}
            onClick={(e) => {
              e.stopPropagation();
              editUser(row.original);
            }}
          />
          <Button
            variant="plain"
            size="micro"
            tone="critical"
            prefixIcon={<IconTrash size={16} />}
            onClick={(e) => {
              e.stopPropagation();
              deleteUser(row.original.id);
            }}
          />
        </div>
      ),
    },
  ]}
  onRowClick={(row) => viewUserDetails(row.original.id)}
/>
```

### Dashboard Analytics Table

Display analytical data with metrics and visual indicators.

```jsx
<Table
  data={analyticsData}
  columns={[
    { accessorKey: 'metric', header: 'Metric' },
    { 
      accessorKey: 'value', 
      header: 'Value',
      cell: ({ row }) => formatNumber(row.original.value),
    },
    { 
      accessorKey: 'change', 
      header: 'Change',
      cell: ({ getValue }) => {
        const change = getValue();
        return (
          <div style={{ 
            color: change > 0 ? 'var(--t-color-text-success)' : 'var(--t-color-text-critical)',
            display: 'flex',
            alignItems: 'center',
            gap: '4px'
          }}>
            {change > 0 ? '‚Üë' : '‚Üì'} {Math.abs(change)}%
          </div>
        );
      },
    },
    { 
      id: 'chart',
      header: 'Trend',
      cell: ({ row }) => <SparklineChart data={row.original.trend} />,
    },
  ]}
  title="Performance Metrics"
  gridCells={true}
/>
```

### Record Selection Table

Table with row selection for batch operations.

```jsx
const [selectedRows, setSelectedRows] = useState([]);

// Define selection column
const selectionColumn = {
  id: 'selection',
  header: ({ table }) => (
    <input
      type="checkbox"
      checked={table.getIsAllRowsSelected()}
      onChange={table.getToggleAllRowsSelectedHandler()}
    />
  ),
  cell: ({ row }) => (
    <input
      type="checkbox"
      checked={row.getIsSelected()}
      onChange={row.getToggleSelectedHandler()}
      onClick={(e) => e.stopPropagation()}
    />
  ),
  size: 40,
};

// Columns with selection
const columnsWithSelection = [selectionColumn, ...columns];

<div>
  <div style={{ marginBottom: '16px' }}>
    <Button 
      disabled={selectedRows.length === 0}
      onClick={() => handleBatchAction(selectedRows)}
    >
      Process Selected ({selectedRows.length})
    </Button>
  </div>
  
  <Table
    data={data}
    columns={columnsWithSelection}
    title="Select Records"
    onRowSelectionChange={setSelectedRows}
  />
</div>
```

## Accessibility

The Table component is built with accessibility in mind:

- Semantic HTML table structure (`<table>`, `<thead>`, `<tbody>`, `<tr>`, `<th>`, `<td>`) for optimal screen reader compatibility
- Appropriate ARIA attributes for sorting, filtering, and pagination
- Keyboard navigation support for all interactive elements
- Focus management for row and cell interactions
- Proper contrast ratios for all visual states
- RTL language support with appropriate text alignment and directional changes
- Visible focus indicators for keyboard users
- Responsive design that works on various screen sizes and devices

## Implementation Details

### CSS Variables

The Table component uses the following token CSS variables:

| Variable | Purpose |
|----------|---------|
| `--t-space-*` | Padding and spacing |
| `--t-typography-body-sm-default` | Typography for text cell variants |
| `--t-font-family-primary` | Text font |
| `--t-font-size-*` | Font sizes for text elements |
| `--t-font-weight-*` | Font weights |
| `--t-color-text-primary` | Primary text color |
| `--t-color-text-secondary` | Secondary text color (multiline second lines) |
| `--t-color-text-tertiary` | Tertiary text color |
| `--t-color-border-*` | Border colors |
| `--t-color-surface-primary` | Table background color |
| `--t-color-surface-hover` | Row hover background color |
| `--t-color-surface-active` | Striped row hover background color |
| `--t-color-surface-secondary` | Header background color |
| `--t-color-fill-*` | Highlight colors |
| `--t-border-radius-*` | Border radius |
| `--t-shadow-*` | Box shadows |
| `--t-duration-*` | Animation duration |
| `--t-line-height-*` | Line height for different languages |

### Technical Architecture

The Table component is built on TanStack Table and includes:

- **Data Processing**: Core row model, filtering, sorting, and pagination
- **State Management**: Component-level React state with controlled inputs
- **Event Handling**: Row and cell click handlers
- **Keyboard Navigation**: Accessible keyboard controls
- **Rendering Optimization**: Efficient rendering with React memoization
- **Styling**: CSS Modules with proper scoping
- **Responsive Design**: Mobile-friendly layout and styling

### Performance Considerations

For optimal performance with large datasets:

- Use server-side pagination for tables with more than 1,000 rows
- Implement server-side sorting and filtering for tables with complex data structures
- Consider virtualization for extremely large datasets
- Optimize column rendering by minimizing complex cell renderers
- Use memoization for expensive cell calculations
- Enable the `manualPagination` option for custom data fetching

### Table Integration with Other Components

The Table component seamlessly integrates with other Tagaddod Design System components:

- **Pagination**: For page navigation
- **Tabs**: For tabbed data views
- **Button**: For action buttons
- **TextInput**: For search functionality
- **FilterItem**: For applying data filters
- **Badge**: For count indicators

## Browser Support

The Table component is compatible with all modern browsers:

- Chrome (latest)
- Firefox (latest)
- Safari (latest)
- Edge (latest)
- Mobile browsers (iOS Safari, Android Chrome)

RTL language support works across all supported browsers.

## Dependencies

The Table component's advanced features require these additional dependencies:

### Column Ordering & Resizing
- `@dnd-kit/core` - Modern drag and drop library for React
- `@dnd-kit/sortable` - Sortable utilities for column reordering
- `@dnd-kit/utilities` - Utility functions for drag and drop

These dependencies are automatically included when you install the Table component and provide:
- **Modern DnD**: React 18+ compatible drag and drop
- **Accessibility**: Full keyboard and screen reader support
- **Performance**: Optimized for smooth interactions
- **Touch Support**: Works on mobile and tablet devices

### Bundle Size Impact
The column management features add approximately 15-20KB to your bundle size. If you don't need these features, they can be tree-shaken out in future versions of the component library.
